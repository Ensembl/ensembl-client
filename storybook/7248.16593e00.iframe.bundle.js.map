{"version":3,"file":"7248.16593e00.iframe.bundle.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+EA;;;;;;AAMA;AAGA;;;;;;;;AAQA;ACmOA;;;;;;;;;;;;;;;;;;;ACvQA;;;;;;;;ACfA","sources":["webpack://ensembl-new/./src/shared/workers/feature-sequence-download/queries/geneAndTranscriptsQuery.ts","webpack://ensembl-new/./src/shared/workers/feature-sequence-download/geneAndTranscriptsDownload.ts","webpack://ensembl-new/./src/shared/workers/feature-sequence-download/proteinDownload.ts","webpack://ensembl-new/./src/shared/workers/feature-sequence-download/genomicSliceDownload.ts"],"sourcesContent":["/**\n * See the NOTICE file distributed with this work for additional information\n * regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { gql } from 'graphql-request';\nimport { Pick2, Pick3, Pick4 } from 'ts-multipick';\n\nimport type { FullGene } from 'src/shared/types/core-api/gene';\nimport type { FullTranscript } from 'src/shared/types/core-api/transcript';\nimport type { SplicedExon } from 'src/shared/types/core-api/exon';\nimport type { FullProductGeneratingContext } from 'src/shared/types/core-api/productGeneratingContext';\n\nconst geneAndTranscriptsFragment = gql`\n  fragment GeneAndTranscripts on Gene {\n    stable_id\n    slice {\n      location {\n        start\n        end\n      }\n      region {\n        sequence {\n          checksum\n        }\n      }\n      strand {\n        code\n      }\n    }\n    transcripts {\n      stable_id\n      relative_location {\n        start\n        end\n      }\n      spliced_exons {\n        index\n        relative_location {\n          start\n          end\n        }\n        exon {\n          stable_id\n        }\n      }\n      product_generating_contexts {\n        cds {\n          sequence {\n            checksum\n          }\n        }\n        cdna {\n          sequence {\n            checksum\n          }\n        }\n        product {\n          stable_id\n          sequence {\n            checksum\n          }\n        }\n      }\n    }\n  }\n`;\n\nexport const geneAndTranscriptsQuery = gql`\n  query GeneAndTranscripts($genomeId: String!, $geneId: String!) {\n    gene(by_id: { genome_id: $genomeId, stable_id: $geneId }) {\n      ...GeneAndTranscripts\n    }\n  }\n  ${geneAndTranscriptsFragment}\n`;\n\nexport const transcriptAndGeneQuery = gql`\n  query TranscriptAndGene($genomeId: String!, $transcriptId: String!) {\n    transcript(by_id: { genome_id: $genomeId, stable_id: $transcriptId }) {\n      gene {\n        ...GeneAndTranscripts\n      }\n    }\n  }\n  ${geneAndTranscriptsFragment}\n`;\n\ntype ExonInResponse = Pick<SplicedExon, 'index' | 'relative_location'> &\n  Pick2<SplicedExon, 'exon', 'stable_id'>;\n\ntype ProductInResponse = Pick<\n  NonNullable<FullProductGeneratingContext['product']>,\n  'stable_id'\n> &\n  Pick2<\n    NonNullable<FullProductGeneratingContext['product']>,\n    'sequence',\n    'checksum'\n  >;\n\ntype ProductGeneratingContextInResponse = Pick3<\n  FullProductGeneratingContext,\n  'cdna',\n  'sequence',\n  'checksum'\n> & {\n  cds: Pick2<\n    NonNullable<FullProductGeneratingContext['cds']>,\n    'sequence',\n    'checksum'\n  > | null;\n  product: ProductInResponse | null;\n};\n\nexport type TranscriptInResponse = Pick<\n  FullTranscript,\n  'stable_id' | 'relative_location'\n> & {\n  spliced_exons: ExonInResponse[];\n  product_generating_contexts: ProductGeneratingContextInResponse[];\n};\n\ntype GeneInResponse = Pick<FullGene, 'stable_id'> &\n  Pick3<FullGene, 'slice', 'location', 'start' | 'end'> &\n  Pick3<FullGene, 'slice', 'strand', 'code'> &\n  Pick4<FullGene, 'slice', 'region', 'sequence', 'checksum'> & {\n    transcripts: TranscriptInResponse[];\n  };\n\nexport type GeneAndTranscriptsResponse = {\n  gene: GeneInResponse;\n};\n\nexport type TranscriptAndGeneResponse = {\n  transcript: {\n    gene: GeneInResponse;\n  };\n};\n","/**\n * See the NOTICE file distributed with this work for additional information\n * regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { GraphQLClient } from 'graphql-request';\n\nimport * as urlFor from 'src/shared/helpers/urlHelper';\nimport { getReverseComplement } from 'src/shared/helpers/sequenceHelpers';\nimport { getExonRelativeLocationInGene } from './genomicSequenceHelpers';\n\nimport {\n  geneAndTranscriptsQuery,\n  transcriptAndGeneQuery,\n  type GeneAndTranscriptsResponse,\n  type TranscriptAndGeneResponse,\n  type TranscriptInResponse\n} from './queries/geneAndTranscriptsQuery';\n\nimport type {\n  GeneDownloadOptions,\n  TranscriptDownloadOptions\n} from './featureSequenceDownload.worker';\n\ntype SequenceDownloadOptions = Pick<\n  GeneDownloadOptions,\n  'geneSequenceTypes' | 'transcriptSequenceTypes'\n>;\n\n/**\n * - Fetch gene and transcripts metadata\n * - Find if genomic sequences have been requested. If yes:\n *  - fetch the sequence of the gene\n *  - create a reverse complement if needed\n * - Iterate in the following order:\n *   - Gene genomic\n *   - Exons gene\n *   - Transcripts\n *      - Transcript genomic\n *      - Transcript cDNA\n *      - Transcript CDS\n *      - Transcript exons, genomic sequence\n *      - Transcript protein\n */\n\n/**\n * Download sequences for one gene, and all of its transcripts\n */\nexport async function* geneAndTranscriptsSequences(\n  params: GeneDownloadOptions\n) {\n  const { genomeId, geneId, geneSequenceTypes, transcriptSequenceTypes } =\n    params;\n  const metadata = await fetchGeneAndTranscriptsMetadata({ genomeId, geneId });\n  const strand = metadata.gene.slice.strand.code;\n\n  let geneSequence = '';\n\n  if (needsGenomicSequence(params)) {\n    const regionChecksum = metadata.gene.slice.region.sequence.checksum;\n    const geneStart = metadata.gene.slice.location.start;\n    const geneEnd = metadata.gene.slice.location.end;\n\n    const refgetUrl = urlFor.refget({\n      checksum: regionChecksum,\n      start: geneStart, // refget is 0-based, end-exclusive\n      end: geneEnd\n    });\n\n    geneSequence = await fetch(refgetUrl).then((response) => response.text());\n    if (strand === 'reverse') {\n      geneSequence = getReverseComplement(geneSequence);\n    }\n  }\n\n  if (geneSequenceTypes?.genomic) {\n    yield {\n      label: `${geneId} genomic`,\n      sequence: geneSequence\n    };\n  }\n  if (geneSequenceTypes?.exons) {\n    for (const transcript of metadata.gene.transcripts) {\n      for (const splicedExon of transcript.spliced_exons) {\n        const exonSequence = getExonSequence({\n          geneSequence,\n          transcript_relative_location: transcript.relative_location,\n          exon_relative_location: splicedExon.relative_location\n        });\n        const exonLabel = buildExonLabel({\n          splicedExon,\n          geneId: metadata.gene.stable_id,\n          transcriptId: transcript.stable_id,\n          exonsCount: transcript.spliced_exons.length\n        });\n\n        yield {\n          label: exonLabel,\n          sequence: exonSequence\n        };\n      }\n    }\n  }\n\n  for (const transcript of metadata.gene.transcripts) {\n    const productGeneratingContext = transcript.product_generating_contexts[0];\n\n    if (transcriptSequenceTypes?.genomic) {\n      const transcriptSequence = getTranscriptSequence({\n        geneSequence,\n        transcript_relative_location: transcript.relative_location\n      });\n      yield {\n        label: `${transcript.stable_id} genomic`,\n        sequence: transcriptSequence\n      };\n    }\n\n    if (transcriptSequenceTypes?.exons) {\n      for (const splicedExon of transcript.spliced_exons) {\n        const exonSequence = getExonSequence({\n          geneSequence,\n          transcript_relative_location: transcript.relative_location,\n          exon_relative_location: splicedExon.relative_location\n        });\n        const exonLabel = buildExonLabel({\n          splicedExon,\n          transcriptId: transcript.stable_id,\n          exonsCount: transcript.spliced_exons.length\n        });\n\n        yield {\n          label: exonLabel,\n          sequence: exonSequence\n        };\n      }\n    }\n\n    if (transcriptSequenceTypes?.cdna) {\n      const sequenceChecksum = productGeneratingContext.cdna.sequence.checksum;\n      const url = urlFor.refget({ checksum: sequenceChecksum });\n      const sequence = await fetch(url).then((response) => response.text());\n      yield {\n        label: `${transcript.stable_id} cdna`,\n        sequence\n      };\n    }\n\n    if (transcriptSequenceTypes?.cds) {\n      const sequenceChecksum = productGeneratingContext.cds?.sequence.checksum;\n      if (sequenceChecksum) {\n        const url = urlFor.refget({ checksum: sequenceChecksum });\n        const sequence = await fetch(url).then((response) => response.text());\n        yield {\n          label: `${transcript.stable_id} cds`,\n          sequence\n        };\n      }\n    }\n\n    if (transcriptSequenceTypes?.protein) {\n      const product = productGeneratingContext.product;\n      if (product) {\n        const sequenceChecksum = product.sequence.checksum;\n        const url = urlFor.refget({ checksum: sequenceChecksum });\n        const sequence = await fetch(url).then((response) => response.text());\n        yield {\n          label: `${product.stable_id} pep`,\n          sequence\n        };\n      }\n    }\n  }\n}\n\n/**\n * Download sequences for one transcript, and for the gene that it belongs to.\n * This function is very similar to geneAndTranscriptsSequences; but it focuses on one transcript\n */\nexport async function* transcriptAndGeneSequences(\n  params: TranscriptDownloadOptions\n) {\n  const { genomeId, transcriptId, geneSequenceTypes, transcriptSequenceTypes } =\n    params;\n  const metadata = await fetchTranscriptAndGeneMetadata({\n    genomeId,\n    transcriptId\n  });\n  const gene = metadata.transcript.gene;\n  const transcript = metadata.transcript.gene.transcripts.find(\n    ({ stable_id }) => stable_id === transcriptId\n  ) as TranscriptInResponse;\n  const strand = metadata.transcript.gene.slice.strand.code;\n\n  let geneSequence = '';\n\n  if (needsGenomicSequence(params)) {\n    const regionChecksum = gene.slice.region.sequence.checksum;\n    const geneStart = gene.slice.location.start;\n    const geneEnd = gene.slice.location.end;\n\n    const refgetUrl = urlFor.refget({\n      checksum: regionChecksum,\n      start: geneStart,\n      end: geneEnd\n    });\n\n    geneSequence = await fetch(refgetUrl).then((response) => response.text());\n    if (strand === 'reverse') {\n      geneSequence = getReverseComplement(geneSequence);\n    }\n  }\n\n  const productGeneratingContext = transcript.product_generating_contexts[0];\n\n  if (transcriptSequenceTypes?.genomic) {\n    const transcriptSequence = getTranscriptSequence({\n      geneSequence,\n      transcript_relative_location: transcript.relative_location\n    });\n    yield {\n      label: `${transcript.stable_id} genomic`,\n      sequence: transcriptSequence\n    };\n  }\n\n  if (transcriptSequenceTypes?.exons) {\n    for (const splicedExon of transcript.spliced_exons) {\n      const exonSequence = getExonSequence({\n        geneSequence,\n        transcript_relative_location: transcript.relative_location,\n        exon_relative_location: splicedExon.relative_location\n      });\n      const exonLabel = buildExonLabel({\n        splicedExon,\n        transcriptId: transcript.stable_id,\n        exonsCount: transcript.spliced_exons.length\n      });\n\n      yield {\n        label: exonLabel,\n        sequence: exonSequence\n      };\n    }\n  }\n\n  if (transcriptSequenceTypes?.cdna) {\n    const sequenceChecksum = productGeneratingContext.cdna.sequence.checksum;\n    const url = urlFor.refget({ checksum: sequenceChecksum });\n    const sequence = await fetch(url).then((response) => response.text());\n    yield {\n      label: `${transcript.stable_id} cdna`,\n      sequence\n    };\n  }\n\n  if (transcriptSequenceTypes?.cds) {\n    const sequenceChecksum = productGeneratingContext.cds?.sequence.checksum;\n    if (sequenceChecksum) {\n      const url = urlFor.refget({ checksum: sequenceChecksum });\n      const sequence = await fetch(url).then((response) => response.text());\n      yield {\n        label: `${transcript.stable_id} cds`,\n        sequence\n      };\n    }\n  }\n\n  if (transcriptSequenceTypes?.protein) {\n    const product = productGeneratingContext.product;\n    if (product) {\n      const sequenceChecksum = product.sequence.checksum;\n      const url = urlFor.refget({ checksum: sequenceChecksum });\n      const sequence = await fetch(url).then((response) => response.text());\n      yield {\n        label: `${product.stable_id} pep`,\n        sequence\n      };\n    }\n  }\n\n  if (geneSequenceTypes?.genomic) {\n    yield {\n      label: `${gene.stable_id} genomic`,\n      sequence: geneSequence\n    };\n  }\n\n  if (geneSequenceTypes?.exons) {\n    for (const transcript of gene.transcripts) {\n      for (const splicedExon of transcript.spliced_exons) {\n        const exonSequence = getExonSequence({\n          geneSequence,\n          transcript_relative_location: transcript.relative_location,\n          exon_relative_location: splicedExon.relative_location\n        });\n        const exonLabel = buildExonLabel({\n          splicedExon,\n          geneId: gene.stable_id,\n          transcriptId: transcript.stable_id,\n          exonsCount: transcript.spliced_exons.length\n        });\n\n        yield {\n          label: exonLabel,\n          sequence: exonSequence\n        };\n      }\n    }\n  }\n}\n\nconst needsGenomicSequence = (params: SequenceDownloadOptions) => {\n  const { geneSequenceTypes, transcriptSequenceTypes } = params;\n\n  return (\n    geneSequenceTypes?.genomic ||\n    geneSequenceTypes?.exons ||\n    transcriptSequenceTypes?.genomic ||\n    transcriptSequenceTypes?.exons\n  );\n};\n\nconst getTranscriptSequence = (params: {\n  geneSequence: string;\n  transcript_relative_location: {\n    start: number;\n    end: number;\n  };\n}) => {\n  const { start, end } = params.transcript_relative_location;\n  return params.geneSequence.slice(start - 1, end);\n};\n\nconst getExonSequence = (params: {\n  geneSequence: string;\n  transcript_relative_location: {\n    start: number;\n    end: number;\n  };\n  exon_relative_location: {\n    start: number;\n    end: number;\n  };\n}) => {\n  const exonRelativeLocationInGene = getExonRelativeLocationInGene({\n    exon: {\n      relative_start: params.exon_relative_location.start,\n      relative_end: params.exon_relative_location.end\n    },\n    transcript: {\n      relative_start: params.transcript_relative_location.start\n    }\n  });\n  const exonStartIndex = exonRelativeLocationInGene.start - 1;\n  const exonEndIndex = exonRelativeLocationInGene.end;\n\n  return params.geneSequence.slice(exonStartIndex, exonEndIndex);\n};\n\nconst buildExonLabel = (params: {\n  transcriptId: string;\n  geneId?: string;\n  splicedExon: GeneAndTranscriptsResponse['gene']['transcripts'][number]['spliced_exons'][number];\n  exonsCount: number;\n}) => {\n  // Proposed heading format:\n  // EXON_ID.VERSION gene:GENE_ID.VERSION transcript:TRANSCRIPT_ID.VERSION exon:N total_exons:exon_count_number{}\n  const {\n    index: exonIndex,\n    exon: { stable_id: exonId }\n  } = params.splicedExon;\n  const genePart = params.geneId ? `gene:${params.geneId} ` : '';\n  const transcriptPart = `transcript:${params.transcriptId} `;\n  const exonOrderPart = `exon:${exonIndex} total_exons:${params.exonsCount}`;\n\n  return `${exonId} ${genePart}${transcriptPart}${exonOrderPart}`;\n};\n\nconst fetchGeneAndTranscriptsMetadata = async (variables: {\n  genomeId: string;\n  geneId: string;\n}) => {\n  // Creating a client below instead of just calling \"request\",\n  // so that it would be possible to inject a JSON serializer,\n  // because either webpack, or comlink break the import of the default json serializer\n  const graphQLClient = new GraphQLClient('/api/graphql/core', {\n    jsonSerializer: JSON\n  });\n\n  return await graphQLClient.request<GeneAndTranscriptsResponse>(\n    geneAndTranscriptsQuery,\n    variables\n  );\n};\n\nconst fetchTranscriptAndGeneMetadata = async (variables: {\n  genomeId: string;\n  transcriptId: string;\n}) => {\n  // Creating a client below instead of just calling \"request\",\n  // so that it would be possible to inject a JSON serializer,\n  // because either webpack, or comlink break the import of the default json serializer\n  const graphQLClient = new GraphQLClient('/api/graphql/core', {\n    jsonSerializer: JSON\n  });\n\n  return await graphQLClient.request<TranscriptAndGeneResponse>(\n    transcriptAndGeneQuery,\n    variables\n  );\n};\n","/**\n * See the NOTICE file distributed with this work for additional information\n * regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { GraphQLClient } from 'graphql-request';\n\nimport * as urlFor from 'src/shared/helpers/urlHelper';\n\nimport {\n  transcriptQueryForProtein,\n  type TranscriptQueryForProteinResponse\n} from './queries/transcriptQueryForProtein';\n\nimport { type ProteinDownloadOptions } from './featureSequenceDownload.worker';\n\nexport async function* getProteinRelatedSequences(\n  params: ProteinDownloadOptions\n) {\n  const metadata = await fetchTranscriptMetadata(params);\n  const transcript = metadata.transcript;\n  // TODO: here, we are assuming that the transcript will only have one product-generating context.\n  // This assumption is correct for now; but if we entered the graph via the product instead of through the transcript,\n  // we wouldn't have had to assume anything.\n  const productGeneratingContext = transcript.product_generating_contexts[0];\n\n  // since we are inside of code that is downloading protein sequences,\n  // we should be able to make an assumption that the product-generating context has both protein and cds\n  if (params.sequenceTypes.protein) {\n    const proteinId = productGeneratingContext.product!.stable_id;\n    const checksum = productGeneratingContext.product!.sequence.checksum;\n    const refgetUrl = urlFor.refget({ checksum });\n    const sequence = await fetch(refgetUrl).then((response) => response.text());\n    yield {\n      label: `${proteinId} pep`,\n      sequence\n    };\n  }\n  if (params.sequenceTypes.cds) {\n    const checksum = productGeneratingContext.cds!.sequence.checksum;\n    const refgetUrl = urlFor.refget({ checksum });\n    const sequence = await fetch(refgetUrl).then((response) => response.text());\n    yield {\n      label: `${transcript.stable_id} cds`,\n      sequence\n    };\n  }\n}\n\nconst fetchTranscriptMetadata = async (variables: {\n  genomeId: string;\n  transcriptId: string;\n}) => {\n  // Creating a client below instead of just calling \"request\",\n  // so that it would be possible to inject a JSON serializer,\n  // because either webpack, or comlink break the import of the default json serializer\n  const graphQLClient = new GraphQLClient('/api/graphql/core', {\n    jsonSerializer: JSON\n  });\n\n  return await graphQLClient.request<TranscriptQueryForProteinResponse>(\n    transcriptQueryForProtein,\n    variables\n  );\n};\n","/**\n * See the NOTICE file distributed with this work for additional information\n * regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { GraphQLClient } from 'graphql-request';\n\nimport * as urlFor from 'src/shared/helpers/urlHelper';\n\nimport {\n  regionChecksumQuery,\n  type RegionChecksumQueryResponse\n} from './queries/regionChecksumQuery';\n\nimport { type GenomicSliceDownloadOptions } from './featureSequenceDownload.worker';\n\nexport const getGenomicSliceSequence = async (\n  params: GenomicSliceDownloadOptions\n) => {\n  const { label, start, end } = params;\n  const metadata = await fetchRegionMetadata(params);\n  const region = metadata.region;\n\n  const checksum = region.sequence.checksum;\n  const refgetUrl = urlFor.refget({ checksum, start, end });\n\n  const sequence = await fetch(refgetUrl).then((response) => response.text());\n\n  return {\n    label,\n    sequence\n  };\n};\n\nconst fetchRegionMetadata = async (variables: {\n  genomeId: string;\n  regionName: string;\n}) => {\n  // Creating a client below instead of just calling \"request\",\n  // so that it would be possible to inject a JSON serializer,\n  // because either webpack, or comlink break the import of the default json serializer\n  const graphQLClient = new GraphQLClient('/api/graphql/core', {\n    jsonSerializer: JSON\n  });\n\n  return await graphQLClient.request<RegionChecksumQueryResponse>(\n    regionChecksumQuery,\n    variables\n  );\n};\n"],"names":[],"sourceRoot":""}