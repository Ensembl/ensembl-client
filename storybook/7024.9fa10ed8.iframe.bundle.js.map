{"version":3,"file":"7024.9fa10ed8.iframe.bundle.js","mappings":";;AAyBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACHA;;;;;;;;;;;ACOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACTA;;;;;;;;;AC2BA","sources":["webpack://ensembl-new/./src/content/app/genome-browser/state/api/queries/trackPanelGeneQuery.ts","webpack://ensembl-new/./src/content/app/genome-browser/state/api/queries/geneSummaryQuery.ts","webpack://ensembl-new/./src/content/app/genome-browser/state/api/queries/transcriptSummaryQuery.ts","webpack://ensembl-new/./src/content/app/genome-browser/state/api/queries/transcriptInZmenuQuery.ts","webpack://ensembl-new/./src/content/app/genome-browser/state/api/queries/variantQuery.ts","webpack://ensembl-new/./src/content/app/genome-browser/state/api/queries/regionQuery.ts","webpack://ensembl-new/./src/content/app/genome-browser/state/api/genomeBrowserApiSlice.ts"],"sourcesContent":["/**\n * See the NOTICE file distributed with this work for additional information\n * regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { gql } from 'graphql-request';\n\ntype Params = {\n  genomeId: string;\n  geneId: string;\n};\n\nconst trackPanelGeneQuery = (params: Params) => gql`\n  query TrackPanelGene {\n    gene(by_id: { genome_id: \"${params.genomeId}\", stable_id: \"${params.geneId}\" }) {\n      stable_id\n      unversioned_stable_id\n      symbol\n      slice {\n        region {\n          name\n        }\n        location {\n          start\n          end\n        }\n        strand {\n          code\n        }\n      }\n      metadata {\n        biotype {\n          label\n        }\n      }\n      transcripts {\n        stable_id\n        slice {\n          location {\n            length\n          }\n        }\n        product_generating_contexts {\n          product_type\n          product {\n            length\n          }\n        }\n        metadata {\n          biotype {\n            label\n            value\n          }\n          canonical {\n            value\n            label\n          }\n          mane {\n            value\n            label\n            ncbi_transcript {\n              id\n              url\n            }\n          }\n        }\n      }\n    }\n  }\n`;\n\nexport default trackPanelGeneQuery;\n","/**\n * See the NOTICE file distributed with this work for additional information\n * regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { gql } from 'graphql-request';\nimport { Pick2, Pick3, Pick4 } from 'ts-multipick';\n\nimport type { FullGene } from 'src/shared/types/core-api/gene';\nimport type { FullTranscript } from 'src/shared/types/core-api/transcript';\nimport type { FullProductGeneratingContext } from 'src/shared/types/core-api/productGeneratingContext';\n\nexport const geneSummaryQuery = gql`\n  query Gene($genomeId: String!, $geneId: String!) {\n    gene(by_id: { genome_id: $genomeId, stable_id: $geneId }) {\n      alternative_symbols\n      name\n      stable_id\n      unversioned_stable_id\n      symbol\n      transcripts {\n        stable_id\n        product_generating_contexts {\n          product_type\n        }\n      }\n      slice {\n        region {\n          sequence {\n            checksum\n          }\n        }\n        strand {\n          code\n        }\n        location {\n          start\n          end\n          length\n        }\n      }\n      metadata {\n        biotype {\n          label\n          value\n          definition\n        }\n        name {\n          accession_id\n          url\n        }\n      }\n    }\n  }\n`;\n\ntype Transcript = Pick<FullTranscript, 'stable_id'> & {\n  product_generating_contexts: Pick<\n    FullProductGeneratingContext,\n    'product_type'\n  >[];\n};\n\ntype GeneMetadata = Pick2<\n  FullGene['metadata'],\n  'biotype',\n  'label' | 'value' | 'definition'\n> & {\n  name: Pick<NonNullable<FullGene['metadata']['name']>, 'accession_id' | 'url'>;\n};\n\ntype GeneSummary = Pick<\n  FullGene,\n  | 'stable_id'\n  | 'unversioned_stable_id'\n  | 'symbol'\n  | 'name'\n  | 'alternative_symbols'\n> & {\n  metadata: GeneMetadata;\n} & Pick3<FullGene, 'slice', 'strand', 'code'> &\n  Pick3<FullGene, 'slice', 'location', 'length' | 'start' | 'end'> &\n  Pick4<FullGene, 'slice', 'region', 'sequence', 'checksum'> & {\n    transcripts: Transcript[];\n  };\n\nexport type GeneSummaryQueryResult = {\n  gene: GeneSummary;\n};\n","/**\n * See the NOTICE file distributed with this work for additional information\n * regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { gql } from 'graphql-request';\nimport type { Pick2, Pick3, Pick4 } from 'ts-multipick';\n\nimport type { FullGene } from 'src/shared/types/core-api/gene';\nimport type { FullTranscript } from 'src/shared/types/core-api/transcript';\nimport type { SplicedExon, PhasedExon } from 'src/shared/types/core-api/exon';\nimport type { FullProductGeneratingContext } from 'src/shared/types/core-api/productGeneratingContext';\nimport type { TranscriptMetadata } from 'src/shared/types/core-api/metadata';\n\nexport const transcriptSummaryQuery = gql`\n  query TranscriptSummary($genomeId: String!, $transcriptId: String!) {\n    transcript(by_id: { genome_id: $genomeId, stable_id: $transcriptId }) {\n      stable_id\n      unversioned_stable_id\n      external_references {\n        accession_id\n        url\n        source {\n          id\n        }\n      }\n      spliced_exons {\n        relative_location {\n          start\n          end\n        }\n        exon {\n          stable_id\n          slice {\n            location {\n              length\n            }\n          }\n        }\n      }\n      product_generating_contexts {\n        product_type\n        default\n        cds {\n          protein_length\n          sequence {\n            checksum\n          }\n        }\n        cdna {\n          sequence {\n            checksum\n          }\n        }\n        phased_exons {\n          start_phase\n          end_phase\n          exon {\n            stable_id\n          }\n        }\n        product {\n          stable_id\n          external_references {\n            accession_id\n            url\n            source {\n              id\n            }\n          }\n          sequence {\n            checksum\n          }\n        }\n      }\n      slice {\n        strand {\n          code\n        }\n        location {\n          start\n          end\n          length\n        }\n        region {\n          name\n          sequence {\n            checksum\n          }\n        }\n      }\n      metadata {\n        biotype {\n          label\n          value\n          definition\n        }\n        canonical {\n          value\n          label\n          definition\n        }\n        mane {\n          value\n          label\n          definition\n        }\n      }\n      gene {\n        name\n        stable_id\n        unversioned_stable_id\n        symbol\n      }\n    }\n  }\n`;\n\ntype GeneInSummaryTranscript = Pick<\n  FullGene,\n  'name' | 'stable_id' | 'unversioned_stable_id' | 'symbol'\n>;\n\ntype SummaryTranscriptMetadata = Pick2<\n  TranscriptMetadata,\n  'biotype',\n  'label' | 'value' | 'definition'\n> & {\n  canonical: Pick<\n    NonNullable<TranscriptMetadata['canonical']>,\n    'label' | 'value' | 'definition'\n  > | null;\n  mane: Pick<\n    NonNullable<TranscriptMetadata['mane']>,\n    'label' | 'value' | 'definition'\n  > | null;\n};\n\ntype RequestedExternalReference = Pick<\n  FullTranscript['external_references'][number],\n  'accession_id' | 'url'\n> &\n  Pick2<FullTranscript['external_references'][number], 'source', 'id'>;\n\ntype SplicedExonOnSummaryTranscript = Pick2<\n  SplicedExon,\n  'relative_location',\n  'start' | 'end'\n> &\n  Pick2<SplicedExon, 'exon', 'stable_id'> &\n  Pick4<SplicedExon, 'exon', 'slice', 'location', 'length'>;\n\ntype PhasedExonOfDefaultTranscript = Pick<\n  PhasedExon,\n  'start_phase' | 'end_phase'\n> &\n  Pick2<PhasedExon, 'exon', 'stable_id'>;\n\ntype ProductGeneratingContextOnSummaryTranscript = Pick<\n  FullProductGeneratingContext,\n  'product_type' | 'default'\n> & {\n  cds:\n    | (Pick<\n        NonNullable<FullProductGeneratingContext['cds']>,\n        'protein_length'\n      > &\n        Pick2<\n          NonNullable<FullProductGeneratingContext['cds']>,\n          'sequence',\n          'checksum'\n        >)\n    | null;\n  cdna: Pick2<\n    NonNullable<FullProductGeneratingContext['cdna']>,\n    'sequence',\n    'checksum'\n  > | null;\n  phased_exons: PhasedExonOfDefaultTranscript[];\n  product:\n    | ({\n        stable_id: string;\n        external_references: RequestedExternalReference[];\n      } & Pick2<\n        NonNullable<FullProductGeneratingContext['product']>,\n        'sequence',\n        'checksum'\n      >)\n    | null;\n};\n\ntype SummaryTranscript = Pick<\n  FullTranscript,\n  'stable_id' | 'unversioned_stable_id'\n> &\n  Pick3<FullTranscript, 'slice', 'strand', 'code'> &\n  Pick4<FullTranscript, 'slice', 'region', 'sequence', 'checksum'> &\n  Pick3<FullTranscript, 'slice', 'location', 'length' | 'start' | 'end'> &\n  Pick3<FullTranscript, 'slice', 'region', 'name'> & {\n    metadata: SummaryTranscriptMetadata;\n    gene: GeneInSummaryTranscript;\n    spliced_exons: SplicedExonOnSummaryTranscript[];\n    product_generating_contexts: ProductGeneratingContextOnSummaryTranscript[];\n    external_references: RequestedExternalReference[];\n  };\n\nexport type TranscriptSummaryQueryResult = {\n  transcript: SummaryTranscript;\n};\n","/**\n * See the NOTICE file distributed with this work for additional information\n * regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { gql } from 'graphql-request';\nimport type { Pick2 } from 'ts-multipick';\n\nimport type { FullTranscript } from 'src/shared/types/core-api/transcript';\nimport type { FullProductGeneratingContext } from 'src/shared/types/core-api/productGeneratingContext';\n\nexport const transcriptZmenuQuery = gql`\n  query Transcript($genomeId: String!, $transcriptId: String!) {\n    transcript(by_id: { genome_id: $genomeId, stable_id: $transcriptId }) {\n      product_generating_contexts {\n        product_type\n      }\n      gene {\n        stable_id\n      }\n    }\n  }\n`;\n\ntype TranscriptInResponse = Pick2<FullTranscript, 'gene', 'stable_id'> & {\n  product_generating_contexts: Pick<\n    FullProductGeneratingContext,\n    'product_type'\n  >[];\n};\n\nexport type TranscriptZmenuQueryResult = {\n  transcript: TranscriptInResponse;\n};\n","/**\n * See the NOTICE file distributed with this work for additional information\n * regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { gql } from 'graphql-request';\nimport { Pick2, Pick3 } from 'ts-multipick';\n\nimport type { Variant } from 'src/shared/types/variation-api/variant';\nimport type { VariantAllele } from 'src/shared/types/variation-api/variantAllele';\n\n/**\n * TODO:\n * - add prediction_results field to the variant query, when it is ready\n * - add prediction_results field to variant allele, when it is ready\n * - add population_frequencies field to variant allele, when it is ready\n * - add phenotype_assertions field to variant allele, when it is ready\n */\nexport const variantDetailsQuery = gql`\n  query VariantDetails($genomeId: String!, $variantId: String!) {\n    variant(by_id: { genome_id: $genomeId, variant_id: $variantId }) {\n      name\n      alternative_names {\n        name\n        url\n      }\n      slice {\n        location {\n          start\n          end\n        }\n        region {\n          name\n        }\n      }\n      allele_type {\n        value\n      }\n      primary_source {\n        url\n        source {\n          name\n          release\n        }\n      }\n      prediction_results {\n        score\n        result\n        analysis_method {\n          tool\n        }\n      }\n      alleles {\n        name\n        allele_type {\n          value\n        }\n        slice {\n          location {\n            start\n            end\n          }\n        }\n        allele_sequence\n        reference_sequence\n        phenotype_assertions {\n          feature\n        }\n        prediction_results {\n          score\n          result\n          analysis_method {\n            tool\n          }\n        }\n        population_frequencies {\n          is_minor_allele\n          is_hpmaf\n          allele_frequency\n        }\n      }\n    }\n  }\n`;\n\ntype VariantDetailsAllele = Pick<\n  VariantAllele,\n  'name' | 'allele_sequence' | 'reference_sequence'\n> &\n  Pick2<VariantAllele, 'allele_type', 'value'> &\n  Pick3<VariantAllele, 'slice', 'location', 'start' | 'end'> & {\n    population_frequencies: VariantDetailsAllelePopulationFrequency[];\n    prediction_results: VariantDetailsAllelePredictionResult[];\n    phenotype_assertions: VariantDetailsAllelePhenotypeAssertion[];\n  };\n\ntype VariantDetailsAllelePopulationFrequency = Pick<\n  VariantAllele['population_frequencies'][number],\n  'is_minor_allele' | 'is_hpmaf' | 'allele_frequency'\n>;\n\ntype VariantDetailsAllelePhenotypeAssertion = Pick<\n  VariantAllele['phenotype_assertions'][number],\n  'feature'\n>; // it doesn't really matter what we request; the point is to check whether the array of assertions will be empty\n\ntype VariantDetailsPredictionResult = Pick<\n  Variant['prediction_results'][number],\n  'result' | 'score'\n> &\n  Pick2<Variant['prediction_results'][number], 'analysis_method', 'tool'>;\n\ntype VariantDetailsAllelePredictionResult = Pick<\n  VariantAllele['prediction_results'][number],\n  'result' | 'score'\n> &\n  Pick2<VariantAllele['prediction_results'][number], 'analysis_method', 'tool'>;\n\nexport type VariantDetails = Pick<Variant, 'name'> &\n  Pick3<Variant, 'slice', 'location', 'start' | 'end'> &\n  Pick3<Variant, 'slice', 'region', 'name'> &\n  Pick2<Variant, 'allele_type', 'value'> &\n  Pick2<Variant, 'primary_source', 'url'> &\n  Pick3<Variant, 'primary_source', 'source', 'name' | 'release'> & {\n    alternative_names: Pick<\n      Variant['alternative_names'][number],\n      'name' | 'url'\n    >[];\n    prediction_results: VariantDetailsPredictionResult[];\n    alleles: VariantDetailsAllele[];\n  };\n\nexport type VariantQueryResult = {\n  variant: VariantDetails;\n};\n","/**\n * See the NOTICE file distributed with this work for additional information\n * regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { gql } from 'graphql-request';\n\nimport type { Region } from 'src/shared/types/core-api/slice';\n\nexport const regionQuery = gql`\n  query Region($genomeId: String!, $regionName: String!) {\n    region(by_name: { genome_id: $genomeId, name: $regionName }) {\n      name\n      length\n      code\n      topology\n    }\n  }\n`;\n\nexport type RegionInResponse = Pick<\n  Region,\n  'name' | 'length' | 'code' | 'topology'\n>;\n\nexport type RegionQueryResult = {\n  region: RegionInResponse;\n};\n","/**\n * See the NOTICE file distributed with this work for additional information\n * regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport config from 'config';\nimport restApiSlice from 'src/shared/state/api-slices/restSlice';\nimport graphqlApiSlice from 'src/shared/state/api-slices/graphqlApiSlice';\n\nimport trackPanelGeneQuery from './queries/trackPanelGeneQuery';\nimport {\n  geneSummaryQuery,\n  type GeneSummaryQueryResult\n} from './queries/geneSummaryQuery';\nimport {\n  transcriptSummaryQuery,\n  type TranscriptSummaryQueryResult\n} from './queries/transcriptSummaryQuery';\nimport {\n  transcriptZmenuQuery,\n  type TranscriptZmenuQueryResult\n} from './queries/transcriptInZmenuQuery';\nimport {\n  variantDetailsQuery,\n  type VariantQueryResult\n} from 'src/content/app/genome-browser/state/api/queries/variantQuery';\nimport { regionQuery, type RegionQueryResult } from './queries/regionQuery';\n\nimport type { GenomeTrackCategory } from 'src/content/app/genome-browser/state/types/tracks';\nimport type { TrackPanelGene } from '../types/track-panel-gene';\n\ntype GeneQueryParams = { genomeId: string; geneId: string };\ntype TranscriptQueryParams = { genomeId: string; transcriptId: string };\ntype RegionQueryParams = { genomeId: string; regionName: string };\ntype VariantQueryParams = { genomeId: string; variantId: string };\n\nconst genomeBrowserApiSlice = graphqlApiSlice.injectEndpoints({\n  endpoints: (builder) => ({\n    getTrackPanelGene: builder.query<{ gene: TrackPanelGene }, GeneQueryParams>(\n      {\n        query: (params) => ({\n          url: config.coreApiUrl,\n          body: trackPanelGeneQuery(params)\n        })\n      }\n    ),\n    gbGeneSummary: builder.query<GeneSummaryQueryResult, GeneQueryParams>({\n      query: (params) => ({\n        url: config.coreApiUrl,\n        body: geneSummaryQuery,\n        variables: params\n      })\n    }),\n    gbTranscriptSummary: builder.query<\n      TranscriptSummaryQueryResult,\n      TranscriptQueryParams\n    >({\n      query: (params) => ({\n        url: config.coreApiUrl,\n        body: transcriptSummaryQuery,\n        variables: params\n      })\n    }),\n    gbTranscriptInZmenu: builder.query<\n      TranscriptZmenuQueryResult,\n      TranscriptQueryParams\n    >({\n      query: (params) => ({\n        url: config.coreApiUrl,\n        body: transcriptZmenuQuery,\n        variables: params\n      })\n    }),\n    gbRegion: builder.query<RegionQueryResult, RegionQueryParams>({\n      query: (params) => ({\n        url: config.coreApiUrl,\n        body: regionQuery,\n        variables: params\n      })\n    }),\n\n    // Maybe move variation endpoints queried from the genome browser into a separate file?\n    gbVariant: builder.query<VariantQueryResult, VariantQueryParams>({\n      query: (params) => ({\n        url: config.variationApiUrl,\n        body: variantDetailsQuery,\n        variables: params\n      })\n    })\n  })\n});\n\ntype GenomeTrackCategoriesResponse = {\n  track_categories: GenomeTrackCategory[];\n};\n\nconst genomeBrowserRestApiSlice = restApiSlice.injectEndpoints({\n  endpoints: (builder) => ({\n    genomeTracks: builder.query<GenomeTrackCategory[], string>({\n      query: (genomeId) => ({\n        url: `${config.tracksApiBaseUrl}/track_categories/${genomeId}`\n      }),\n      transformResponse: (response: GenomeTrackCategoriesResponse) => {\n        /**\n         * NOTE: the transformation inside of the map function below is rather disturbing,\n         * and should be replaced with something better.\n         * It is intended to fix the discrepancy between how the genome browser client identifies a track\n         * (it uses the path to the track that triggers the appropriate genome browser program),\n         * and how the track api identifies a track.\n         *\n         * Genome browser will report back to the browser chrome the tracks that it has enabled,\n         * using the ids from the track path (i.e. the last string in track trigger arrays).\n         * Browser chrome needs to be able to recognize these messages and to respond to them appropriately.\n         * For which purpose, we are here redefining track ids as the last string inside of track trigger array.\n         */\n        return response.track_categories.map((category) => ({\n          ...category,\n          track_list: category.track_list.map((track) => ({\n            ...track,\n            track_id: (track.track_id = track.trigger.at(-1) as string)\n          }))\n        }));\n      }\n    })\n  })\n});\n\nexport const { getTrackPanelGene, gbRegion: getGBRegion } =\n  genomeBrowserApiSlice.endpoints;\nexport const {\n  useGetTrackPanelGeneQuery,\n  useGbGeneSummaryQuery,\n  useGbTranscriptSummaryQuery,\n  useGbTranscriptInZmenuQuery,\n  useGbRegionQuery,\n  useGbVariantQuery\n} = genomeBrowserApiSlice;\n\nexport const { useGenomeTracksQuery } = genomeBrowserRestApiSlice;\n"],"names":[],"sourceRoot":""}