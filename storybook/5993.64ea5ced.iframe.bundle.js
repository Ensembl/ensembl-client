/*! For license information please see 5993.64ea5ced.iframe.bundle.js.LICENSE.txt */
"use strict";(globalThis.webpackChunkensembl_new=globalThis.webpackChunkensembl_new||[]).push([[5993],{"./node_modules/@reduxjs/toolkit/dist/query/react/rtk-query-react.modern.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{xP:()=>createApi});var _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__("./node_modules/@reduxjs/toolkit/dist/query/rtk-query.modern.mjs"),react_redux__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/react-redux/dist/react-redux.mjs"),reselect__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__("./node_modules/reselect/dist/reselect.mjs"),_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/redux/dist/redux.mjs"),_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__("./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs"),react__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/react/index.js");__webpack_require__("./node_modules/process/browser.js");function capitalize(str){return str.replace(str[0],str[0].toUpperCase())}function safeAssign(target,...args){return Object.assign(target,...args)}var cache=WeakMap?new WeakMap:void 0,defaultSerializeQueryArgs=({endpointName,queryArgs})=>{let serialized="";const cached=cache?.get(queryArgs);if("string"==typeof cached)serialized=cached;else{const stringified=JSON.stringify(queryArgs,((key,value)=>(value="bigint"==typeof value?{$bigint:value.toString()}:value,value=(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.Qd)(value)?Object.keys(value).sort().reduce(((acc,key2)=>(acc[key2]=value[key2],acc)),{}):value)));(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.Qd)(queryArgs)&&cache?.set(queryArgs,stringified),serialized=stringified}return`${endpointName}(${serialized})`},UNINITIALIZED_VALUE=Symbol();function useStableQueryArgs(queryArgs,serialize,endpointDefinition,endpointName){const incoming=(0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)((()=>({queryArgs,serialized:"object"==typeof queryArgs?serialize({queryArgs,endpointDefinition,endpointName}):queryArgs})),[queryArgs,serialize,endpointDefinition,endpointName]),cache2=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(incoming);return(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)((()=>{cache2.current.serialized!==incoming.serialized&&(cache2.current=incoming)}),[incoming]),cache2.current.serialized===incoming.serialized?cache2.current.queryArgs:queryArgs}function useShallowStableValue(value){const cache2=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value);return(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)((()=>{(0,react_redux__WEBPACK_IMPORTED_MODULE_2__.bN)(cache2.current,value)||(cache2.current=value)}),[value]),(0,react_redux__WEBPACK_IMPORTED_MODULE_2__.bN)(cache2.current,value)?cache2.current:value}var isDOM=(()=>!("undefined"==typeof window||void 0===window.document||void 0===window.document.createElement))(),isReactNative=(()=>"undefined"!=typeof navigator&&"ReactNative"===navigator.product)(),useIsomorphicLayoutEffect=(()=>isDOM||isReactNative?react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect:react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(),noPendingQueryStateSelector=selected=>selected.isUninitialized?{...selected,isUninitialized:!1,isFetching:!0,isLoading:void 0===selected.data,status:_reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.RE.pending}:selected;var reactHooksModuleName=Symbol();var createApi=(0,_reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.l0)((0,_reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.m7)(),(({batch=react_redux__WEBPACK_IMPORTED_MODULE_2__.vA,hooks={useDispatch:react_redux__WEBPACK_IMPORTED_MODULE_2__.wA,useSelector:react_redux__WEBPACK_IMPORTED_MODULE_2__.d4,useStore:react_redux__WEBPACK_IMPORTED_MODULE_2__.Pj},createSelector:createSelector2=reselect__WEBPACK_IMPORTED_MODULE_5__.Mz,unstable__sideEffectsInRender=!1,...rest}={})=>({name:reactHooksModuleName,init(api,{serializeQueryArgs},context){const anyApi=api,{buildQueryHooks,buildMutationHook,usePrefetch}=function buildHooks({api,moduleOptions:{batch,hooks:{useDispatch,useSelector,useStore},unstable__sideEffectsInRender,createSelector:createSelector2},serializeQueryArgs,context}){const usePossiblyImmediateEffect=unstable__sideEffectsInRender?cb=>cb():react__WEBPACK_IMPORTED_MODULE_0__.useEffect;return{buildQueryHooks:function buildQueryHooks(name){const useQuerySubscription=(arg,{refetchOnReconnect,refetchOnFocus,refetchOnMountOrArgChange,skip=!1,pollingInterval=0,skipPollingIfUnfocused=!1}={})=>{const{initiate}=api.endpoints[name],dispatch=useDispatch(),subscriptionSelectorsRef=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(void 0);if(!subscriptionSelectorsRef.current){const returnedValue=dispatch(api.internalActions.internal_getRTKQSubscriptions());subscriptionSelectorsRef.current=returnedValue}const stableArg=useStableQueryArgs(skip?_reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.hT:arg,defaultSerializeQueryArgs,context.endpointDefinitions[name],name),stableSubscriptionOptions=useShallowStableValue({refetchOnReconnect,refetchOnFocus,pollingInterval,skipPollingIfUnfocused}),lastRenderHadSubscription=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(!1),promiseRef=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(void 0);let{queryCacheKey,requestId}=promiseRef.current||{},currentRenderHasSubscription=!1;queryCacheKey&&requestId&&(currentRenderHasSubscription=subscriptionSelectorsRef.current.isRequestSubscribed(queryCacheKey,requestId));const subscriptionRemoved=!currentRenderHasSubscription&&lastRenderHadSubscription.current;return usePossiblyImmediateEffect((()=>{lastRenderHadSubscription.current=currentRenderHasSubscription})),usePossiblyImmediateEffect((()=>{subscriptionRemoved&&(promiseRef.current=void 0)}),[subscriptionRemoved]),usePossiblyImmediateEffect((()=>{const lastPromise=promiseRef.current;if(stableArg===_reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.hT)return lastPromise?.unsubscribe(),void(promiseRef.current=void 0);const lastSubscriptionOptions=promiseRef.current?.subscriptionOptions;if(lastPromise&&lastPromise.arg===stableArg)stableSubscriptionOptions!==lastSubscriptionOptions&&lastPromise.updateSubscriptionOptions(stableSubscriptionOptions);else{lastPromise?.unsubscribe();const promise=dispatch(initiate(stableArg,{subscriptionOptions:stableSubscriptionOptions,forceRefetch:refetchOnMountOrArgChange}));promiseRef.current=promise}}),[dispatch,initiate,refetchOnMountOrArgChange,stableArg,stableSubscriptionOptions,subscriptionRemoved]),(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)((()=>()=>{promiseRef.current?.unsubscribe(),promiseRef.current=void 0}),[]),(0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)((()=>({refetch:()=>{if(!promiseRef.current)throw new Error((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_4__.gk)(38));return promiseRef.current?.refetch()}})),[])},useLazyQuerySubscription=({refetchOnReconnect,refetchOnFocus,pollingInterval=0,skipPollingIfUnfocused=!1}={})=>{const{initiate}=api.endpoints[name],dispatch=useDispatch(),[arg,setArg]=(0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(UNINITIALIZED_VALUE),promiseRef=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(void 0),stableSubscriptionOptions=useShallowStableValue({refetchOnReconnect,refetchOnFocus,pollingInterval,skipPollingIfUnfocused});usePossiblyImmediateEffect((()=>{const lastSubscriptionOptions=promiseRef.current?.subscriptionOptions;stableSubscriptionOptions!==lastSubscriptionOptions&&promiseRef.current?.updateSubscriptionOptions(stableSubscriptionOptions)}),[stableSubscriptionOptions]);const subscriptionOptionsRef=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(stableSubscriptionOptions);usePossiblyImmediateEffect((()=>{subscriptionOptionsRef.current=stableSubscriptionOptions}),[stableSubscriptionOptions]);const trigger=(0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((function(arg2,preferCacheValue=!1){let promise;return batch((()=>{promiseRef.current?.unsubscribe(),promiseRef.current=promise=dispatch(initiate(arg2,{subscriptionOptions:subscriptionOptionsRef.current,forceRefetch:!preferCacheValue})),setArg(arg2)})),promise}),[dispatch,initiate]),reset=(0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((()=>{promiseRef.current?.queryCacheKey&&dispatch(api.internalActions.removeQueryResult({queryCacheKey:promiseRef.current?.queryCacheKey}))}),[dispatch]);return(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)((()=>()=>{promiseRef?.current?.unsubscribe()}),[]),(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)((()=>{arg===UNINITIALIZED_VALUE||promiseRef.current||trigger(arg,!0)}),[arg,trigger]),(0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)((()=>[trigger,arg,{reset}]),[trigger,arg,reset])},useQueryState=(arg,{skip=!1,selectFromResult}={})=>{const{select}=api.endpoints[name],stableArg=useStableQueryArgs(skip?_reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.hT:arg,serializeQueryArgs,context.endpointDefinitions[name],name),lastValue=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(void 0),selectDefaultResult=(0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)((()=>createSelector2([select(stableArg),(_,lastResult)=>lastResult,_=>stableArg],queryStatePreSelector,{memoizeOptions:{resultEqualityCheck:react_redux__WEBPACK_IMPORTED_MODULE_2__.bN}})),[select,stableArg]),querySelector=(0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)((()=>selectFromResult?createSelector2([selectDefaultResult],selectFromResult,{devModeChecks:{identityFunctionCheck:"never"}}):selectDefaultResult),[selectDefaultResult,selectFromResult]),currentState=useSelector((state=>querySelector(state,lastValue.current)),react_redux__WEBPACK_IMPORTED_MODULE_2__.bN),store=useStore(),newLastValue=selectDefaultResult(store.getState(),lastValue.current);return useIsomorphicLayoutEffect((()=>{lastValue.current=newLastValue}),[newLastValue]),currentState};return{useQueryState,useQuerySubscription,useLazyQuerySubscription,useLazyQuery(options){const[trigger,arg,{reset}]=useLazyQuerySubscription(options),queryStateResults=useQueryState(arg,{...options,skip:arg===UNINITIALIZED_VALUE}),info=(0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)((()=>({lastArg:arg})),[arg]);return(0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)((()=>[trigger,{...queryStateResults,reset},info]),[trigger,queryStateResults,reset,info])},useQuery(arg,options){const querySubscriptionResults=useQuerySubscription(arg,options),queryStateResults=useQueryState(arg,{selectFromResult:arg===_reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.hT||options?.skip?void 0:noPendingQueryStateSelector,...options}),{data,status,isLoading,isSuccess,isError,error}=queryStateResults;return(0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)({data,status,isLoading,isSuccess,isError,error}),(0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)((()=>({...queryStateResults,...querySubscriptionResults})),[queryStateResults,querySubscriptionResults])}}},buildMutationHook:function buildMutationHook(name){return({selectFromResult,fixedCacheKey}={})=>{const{select,initiate}=api.endpoints[name],dispatch=useDispatch(),[promise,setPromise]=(0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)((()=>()=>{promise?.arg.fixedCacheKey||promise?.reset()}),[promise]);const triggerMutation=(0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((function(arg){const promise2=dispatch(initiate(arg,{fixedCacheKey}));return setPromise(promise2),promise2}),[dispatch,initiate,fixedCacheKey]),{requestId}=promise||{},selectDefaultResult=(0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)((()=>select({fixedCacheKey,requestId:promise?.requestId})),[fixedCacheKey,promise,select]),mutationSelector=(0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)((()=>selectFromResult?createSelector2([selectDefaultResult],selectFromResult):selectDefaultResult),[selectFromResult,selectDefaultResult]),currentState=useSelector(mutationSelector,react_redux__WEBPACK_IMPORTED_MODULE_2__.bN),originalArgs=null==fixedCacheKey?promise?.arg.originalArgs:void 0,reset=(0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((()=>{batch((()=>{promise&&setPromise(void 0),fixedCacheKey&&dispatch(api.internalActions.removeMutationResult({requestId,fixedCacheKey}))}))}),[dispatch,fixedCacheKey,promise,requestId]),{endpointName,data,status,isLoading,isSuccess,isError,error}=currentState;(0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)({endpointName,data,status,isLoading,isSuccess,isError,error});const finalState=(0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)((()=>({...currentState,originalArgs,reset})),[currentState,originalArgs,reset]);return(0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)((()=>[triggerMutation,finalState]),[triggerMutation,finalState])}},usePrefetch:function usePrefetch(endpointName,defaultOptions){const dispatch=useDispatch(),stableDefaultOptions=useShallowStableValue(defaultOptions);return(0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(((arg,options)=>dispatch(api.util.prefetch(endpointName,arg,{...stableDefaultOptions,...options}))),[endpointName,dispatch,stableDefaultOptions])}};function queryStatePreSelector(currentState,lastResult,queryArgs){if(lastResult?.endpointName&&currentState.isUninitialized){const{endpointName}=lastResult,endpointDefinition=context.endpointDefinitions[endpointName];queryArgs!==_reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.hT&&serializeQueryArgs({queryArgs:lastResult.originalArgs,endpointDefinition,endpointName})===serializeQueryArgs({queryArgs,endpointDefinition,endpointName})&&(lastResult=void 0)}let data=currentState.isSuccess?currentState.data:lastResult?.data;void 0===data&&(data=currentState.data);const hasData=void 0!==data,isFetching=currentState.isLoading,isLoading=(!lastResult||lastResult.isLoading||lastResult.isUninitialized)&&!hasData&&isFetching,isSuccess=currentState.isSuccess||hasData&&(isFetching&&!lastResult?.isError||currentState.isUninitialized);return{...currentState,data,currentData:currentState.data,isFetching,isLoading,isSuccess}}}({api,moduleOptions:{batch,hooks,unstable__sideEffectsInRender,createSelector:createSelector2},serializeQueryArgs,context});return safeAssign(anyApi,{usePrefetch}),safeAssign(context,{batch}),{injectEndpoint(endpointName,definition){if(function isQueryDefinition(e){return"query"===e.type}(definition)){const{useQuery,useLazyQuery,useLazyQuerySubscription,useQueryState,useQuerySubscription}=buildQueryHooks(endpointName);safeAssign(anyApi.endpoints[endpointName],{useQuery,useLazyQuery,useLazyQuerySubscription,useQueryState,useQuerySubscription}),api[`use${capitalize(endpointName)}Query`]=useQuery,api[`useLazy${capitalize(endpointName)}Query`]=useLazyQuery}else if(function isMutationDefinition(e){return"mutation"===e.type}(definition)){const useMutation=buildMutationHook(endpointName);safeAssign(anyApi.endpoints[endpointName],{useMutation}),api[`use${capitalize(endpointName)}Mutation`]=useMutation}}}}}))())},"./node_modules/@reduxjs/toolkit/dist/query/rtk-query.modern.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{L5:()=>retry,RE:()=>QueryStatus,cw:()=>fetchBaseQuery,hT:()=>skipToken,l0:()=>buildCreateApi,m7:()=>coreModule});var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/redux/dist/redux.mjs"),_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs"),immer__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/immer/dist/immer.mjs"),reselect__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__("./node_modules/reselect/dist/reselect.mjs"),QueryStatus=(__webpack_require__("./node_modules/process/browser.js"),(QueryStatus2=>(QueryStatus2.uninitialized="uninitialized",QueryStatus2.pending="pending",QueryStatus2.fulfilled="fulfilled",QueryStatus2.rejected="rejected",QueryStatus2))(QueryStatus||{}));var isPlainObject2=_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.Qd;function copyWithStructuralSharing(oldObj,newObj){if(oldObj===newObj||!(isPlainObject2(oldObj)&&isPlainObject2(newObj)||Array.isArray(oldObj)&&Array.isArray(newObj)))return newObj;const newKeys=Object.keys(newObj),oldKeys=Object.keys(oldObj);let isSameObject=newKeys.length===oldKeys.length;const mergeObj=Array.isArray(newObj)?[]:{};for(const key of newKeys)mergeObj[key]=copyWithStructuralSharing(oldObj[key],newObj[key]),isSameObject&&(isSameObject=oldObj[key]===mergeObj[key]);return isSameObject?oldObj:mergeObj}function countObjectKeys(obj){let count=0;for(const _key in obj)count++;return count}var flatten=arr=>[].concat(...arr);function isNotNullish(v){return null!=v}var withoutTrailingSlash=url=>url.replace(/\/$/,""),withoutLeadingSlash=url=>url.replace(/^\//,"");function joinUrls(base,url){if(!base)return url;if(!url)return base;if(function isAbsoluteUrl(url){return new RegExp("(^|:)//").test(url)}(url))return url;const delimiter=base.endsWith("/")||!url.startsWith("?")?"/":"";return`${base=withoutTrailingSlash(base)}${delimiter}${url=withoutLeadingSlash(url)}`}var defaultFetchFn=(...args)=>fetch(...args),defaultValidateStatus=response=>response.status>=200&&response.status<=299,defaultIsJsonContentType=headers=>/ion\/(vnd\.api\+)?json/.test(headers.get("content-type")||"");function stripUndefined(obj){if(!(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.Qd)(obj))return obj;const copy={...obj};for(const[k,v]of Object.entries(copy))void 0===v&&delete copy[k];return copy}function fetchBaseQuery({baseUrl,prepareHeaders=x=>x,fetchFn=defaultFetchFn,paramsSerializer,isJsonContentType=defaultIsJsonContentType,jsonContentType="application/json",jsonReplacer,timeout:defaultTimeout,responseHandler:globalResponseHandler,validateStatus:globalValidateStatus,...baseFetchOptions}={}){return"undefined"==typeof fetch&&fetchFn===defaultFetchFn&&console.warn("Warning: `fetch` is not available. Please supply a custom `fetchFn` property to use `fetchBaseQuery` on SSR environments."),async(arg,api,extraOptions)=>{const{getState,extra,endpoint,forced,type}=api;let meta,abortController,{url,headers=new Headers(baseFetchOptions.headers),params,responseHandler=globalResponseHandler??"json",validateStatus=globalValidateStatus??defaultValidateStatus,timeout=defaultTimeout,...rest}="string"==typeof arg?{url:arg}:arg,signal=api.signal;timeout&&(abortController=new AbortController,api.signal.addEventListener("abort",abortController.abort),signal=abortController.signal);let config={...baseFetchOptions,signal,...rest};headers=new Headers(stripUndefined(headers)),config.headers=await prepareHeaders(headers,{getState,arg,extra,endpoint,forced,type,extraOptions})||headers;const isJsonifiable=body=>"object"==typeof body&&((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.Qd)(body)||Array.isArray(body)||"function"==typeof body.toJSON);if(!config.headers.has("content-type")&&isJsonifiable(config.body)&&config.headers.set("content-type",jsonContentType),isJsonifiable(config.body)&&isJsonContentType(config.headers)&&(config.body=JSON.stringify(config.body,jsonReplacer)),params){const divider=~url.indexOf("?")?"&":"?";url+=divider+(paramsSerializer?paramsSerializer(params):new URLSearchParams(stripUndefined(params)))}url=joinUrls(baseUrl,url);const request=new Request(url,config);meta={request:new Request(url,config)};let response,timedOut=!1,timeoutId=abortController&&setTimeout((()=>{timedOut=!0,abortController.abort()}),timeout);try{response=await fetchFn(request)}catch(e){return{error:{status:timedOut?"TIMEOUT_ERROR":"FETCH_ERROR",error:String(e)},meta}}finally{timeoutId&&clearTimeout(timeoutId),abortController?.signal.removeEventListener("abort",abortController.abort)}const responseClone=response.clone();let resultData;meta.response=responseClone;let responseText="";try{let handleResponseError;if(await Promise.all([handleResponse(response,responseHandler).then((r=>resultData=r),(e=>handleResponseError=e)),responseClone.text().then((r=>responseText=r),(()=>{}))]),handleResponseError)throw handleResponseError}catch(e){return{error:{status:"PARSING_ERROR",originalStatus:response.status,data:responseText,error:String(e)},meta}}return validateStatus(response,resultData)?{data:resultData,meta}:{error:{status:response.status,data:resultData},meta}};async function handleResponse(response,responseHandler){if("function"==typeof responseHandler)return responseHandler(response);if("content-type"===responseHandler&&(responseHandler=isJsonContentType(response.headers)?"json":"text"),"json"===responseHandler){const text=await response.text();return text.length?JSON.parse(text):null}return response.text()}}var HandledError=class{constructor(value,meta=void 0){this.value=value,this.meta=meta}};async function defaultBackoff(attempt=0,maxRetries=5){const attempts=Math.min(attempt,maxRetries),timeout=~~((Math.random()+.4)*(300<<attempts));await new Promise((resolve=>setTimeout((res=>resolve(res)),timeout)))}var EMPTY_OPTIONS={},retryWithBackoff=(baseQuery,defaultOptions)=>async(args,api,extraOptions)=>{const possibleMaxRetries=[5,(defaultOptions||EMPTY_OPTIONS).maxRetries,(extraOptions||EMPTY_OPTIONS).maxRetries].filter((x=>void 0!==x)),[maxRetries]=possibleMaxRetries.slice(-1),options={maxRetries,backoff:defaultBackoff,retryCondition:(_,__,{attempt})=>attempt<=maxRetries,...defaultOptions,...extraOptions};let retry2=0;for(;;)try{const result=await baseQuery(args,api,extraOptions);if(result.error)throw new HandledError(result);return result}catch(e){if(retry2++,e.throwImmediately){if(e instanceof HandledError)return e.value;throw e}if(e instanceof HandledError&&!options.retryCondition(e.value.error,args,{attempt:retry2,baseQueryApi:api,extraOptions}))return e.value;await options.backoff(retry2,options.maxRetries)}},retry=Object.assign(retryWithBackoff,{fail:function fail(error,meta){throw Object.assign(new HandledError({error,meta}),{throwImmediately:!0})}}),onFocus=(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.VP)("__rtkq/focused"),onFocusLost=(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.VP)("__rtkq/unfocused"),onOnline=(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.VP)("__rtkq/online"),onOffline=(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.VP)("__rtkq/offline");function isQueryDefinition(e){return"query"===e.type}function calculateProvidedBy(description,result,error,queryArg,meta,assertTagTypes){return function isFunction(t){return"function"==typeof t}(description)?description(result,error,queryArg,meta).filter(isNotNullish).map(expandTagDescription).map(assertTagTypes):Array.isArray(description)?description.map(expandTagDescription).map(assertTagTypes):[]}function expandTagDescription(description){return"string"==typeof description?{type:description}:description}var forceQueryFnSymbol=Symbol("forceQueryFn"),isUpsertQuery=arg=>"function"==typeof arg[forceQueryFnSymbol];function defaultTransformResponse(baseQueryReturnValue){return baseQueryReturnValue}function calculateProvidedByThunk(action,type,endpointDefinitions,assertTagType){return calculateProvidedBy(endpointDefinitions[action.meta.arg.endpointName][type],(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.sf)(action)?action.payload:void 0,(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.WA)(action)?action.payload:void 0,action.meta.arg.originalArgs,"baseQueryMeta"in action.meta?action.meta.baseQueryMeta:void 0,assertTagType)}function updateQuerySubstateIfExists(state,queryCacheKey,update){const substate=state[queryCacheKey];substate&&update(substate)}function getMutationCacheKey(id){return("arg"in id?id.arg.fixedCacheKey:id.fixedCacheKey)??id.requestId}function updateMutationSubstateIfExists(state,id,update){const substate=state[getMutationCacheKey(id)];substate&&update(substate)}var initialState={};function buildSlice({reducerPath,queryThunk,mutationThunk,serializeQueryArgs,context:{endpointDefinitions:definitions,apiUid,extractRehydrationInfo,hasRehydrationInfo},assertTagType,config}){const resetApiState=(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.VP)(`${reducerPath}/resetApiState`);function writePendingCacheEntry(draft,arg,upserting,meta){draft[arg.queryCacheKey]??={status:"uninitialized",endpointName:arg.endpointName},updateQuerySubstateIfExists(draft,arg.queryCacheKey,(substate=>{substate.status="pending",substate.requestId=upserting&&substate.requestId?substate.requestId:meta.requestId,void 0!==arg.originalArgs&&(substate.originalArgs=arg.originalArgs),substate.startedTimeStamp=meta.startedTimeStamp}))}function writeFulfilledCacheEntry(draft,meta,payload,upserting){updateQuerySubstateIfExists(draft,meta.arg.queryCacheKey,(substate=>{if(substate.requestId!==meta.requestId&&!upserting)return;const{merge}=definitions[meta.arg.endpointName];if(substate.status="fulfilled",merge)if(void 0!==substate.data){const{fulfilledTimeStamp,arg,baseQueryMeta,requestId}=meta;let newData=(0,immer__WEBPACK_IMPORTED_MODULE_2__.jM)(substate.data,(draftSubstateData=>merge(draftSubstateData,payload,{arg:arg.originalArgs,baseQueryMeta,fulfilledTimeStamp,requestId})));substate.data=newData}else substate.data=payload;else substate.data=definitions[meta.arg.endpointName].structuralSharing??1?copyWithStructuralSharing((0,immer__WEBPACK_IMPORTED_MODULE_2__.Qx)(substate.data)?(0,immer__WEBPACK_IMPORTED_MODULE_2__.c2)(substate.data):substate.data,payload):payload;delete substate.error,substate.fulfilledTimeStamp=meta.fulfilledTimeStamp}))}const querySlice=(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.Z0)({name:`${reducerPath}/queries`,initialState,reducers:{removeQueryResult:{reducer(draft,{payload:{queryCacheKey}}){delete draft[queryCacheKey]},prepare:(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.aA)()},cacheEntriesUpserted:{reducer(draft,action){for(const entry of action.payload){const{queryDescription:arg,value}=entry;writePendingCacheEntry(draft,arg,!0,{arg,requestId:action.meta.requestId,startedTimeStamp:action.meta.timestamp}),writeFulfilledCacheEntry(draft,{arg,requestId:action.meta.requestId,fulfilledTimeStamp:action.meta.timestamp,baseQueryMeta:{}},value,!0)}},prepare:payload=>({payload:payload.map((entry=>{const{endpointName,arg,value}=entry,endpointDefinition=definitions[endpointName];return{queryDescription:{type:"query",endpointName,originalArgs:entry.arg,queryCacheKey:serializeQueryArgs({queryArgs:arg,endpointDefinition,endpointName})},value}})),meta:{[_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.cN]:!0,requestId:(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.Ak)(),timestamp:Date.now()}})},queryResultPatched:{reducer(draft,{payload:{queryCacheKey,patches}}){updateQuerySubstateIfExists(draft,queryCacheKey,(substate=>{substate.data=(0,immer__WEBPACK_IMPORTED_MODULE_2__.$i)(substate.data,patches.concat())}))},prepare:(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.aA)()}},extraReducers(builder){builder.addCase(queryThunk.pending,((draft,{meta,meta:{arg}})=>{writePendingCacheEntry(draft,arg,isUpsertQuery(arg),meta)})).addCase(queryThunk.fulfilled,((draft,{meta,payload})=>{writeFulfilledCacheEntry(draft,meta,payload,isUpsertQuery(meta.arg))})).addCase(queryThunk.rejected,((draft,{meta:{condition,arg,requestId},error,payload})=>{updateQuerySubstateIfExists(draft,arg.queryCacheKey,(substate=>{if(condition);else{if(substate.requestId!==requestId)return;substate.status="rejected",substate.error=payload??error}}))})).addMatcher(hasRehydrationInfo,((draft,action)=>{const{queries}=extractRehydrationInfo(action);for(const[key,entry]of Object.entries(queries))"fulfilled"!==entry?.status&&"rejected"!==entry?.status||(draft[key]=entry)}))}}),mutationSlice=(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.Z0)({name:`${reducerPath}/mutations`,initialState,reducers:{removeMutationResult:{reducer(draft,{payload}){const cacheKey=getMutationCacheKey(payload);cacheKey in draft&&delete draft[cacheKey]},prepare:(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.aA)()}},extraReducers(builder){builder.addCase(mutationThunk.pending,((draft,{meta,meta:{requestId,arg,startedTimeStamp}})=>{arg.track&&(draft[getMutationCacheKey(meta)]={requestId,status:"pending",endpointName:arg.endpointName,startedTimeStamp})})).addCase(mutationThunk.fulfilled,((draft,{payload,meta})=>{meta.arg.track&&updateMutationSubstateIfExists(draft,meta,(substate=>{substate.requestId===meta.requestId&&(substate.status="fulfilled",substate.data=payload,substate.fulfilledTimeStamp=meta.fulfilledTimeStamp)}))})).addCase(mutationThunk.rejected,((draft,{payload,error,meta})=>{meta.arg.track&&updateMutationSubstateIfExists(draft,meta,(substate=>{substate.requestId===meta.requestId&&(substate.status="rejected",substate.error=payload??error)}))})).addMatcher(hasRehydrationInfo,((draft,action)=>{const{mutations}=extractRehydrationInfo(action);for(const[key,entry]of Object.entries(mutations))"fulfilled"!==entry?.status&&"rejected"!==entry?.status||key===entry?.requestId||(draft[key]=entry)}))}}),invalidationSlice=(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.Z0)({name:`${reducerPath}/invalidation`,initialState,reducers:{updateProvidedBy:{reducer(draft,action){const{queryCacheKey,providedTags}=action.payload;for(const tagTypeSubscriptions of Object.values(draft))for(const idSubscriptions of Object.values(tagTypeSubscriptions)){const foundAt=idSubscriptions.indexOf(queryCacheKey);-1!==foundAt&&idSubscriptions.splice(foundAt,1)}for(const{type,id}of providedTags){const subscribedQueries=(draft[type]??={})[id||"__internal_without_id"]??=[];subscribedQueries.includes(queryCacheKey)||subscribedQueries.push(queryCacheKey)}},prepare:(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.aA)()}},extraReducers(builder){builder.addCase(querySlice.actions.removeQueryResult,((draft,{payload:{queryCacheKey}})=>{for(const tagTypeSubscriptions of Object.values(draft))for(const idSubscriptions of Object.values(tagTypeSubscriptions)){const foundAt=idSubscriptions.indexOf(queryCacheKey);-1!==foundAt&&idSubscriptions.splice(foundAt,1)}})).addMatcher(hasRehydrationInfo,((draft,action)=>{const{provided}=extractRehydrationInfo(action);for(const[type,incomingTags]of Object.entries(provided))for(const[id,cacheKeys]of Object.entries(incomingTags)){const subscribedQueries=(draft[type]??={})[id||"__internal_without_id"]??=[];for(const queryCacheKey of cacheKeys){subscribedQueries.includes(queryCacheKey)||subscribedQueries.push(queryCacheKey)}}})).addMatcher((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.i0)((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.sf)(queryThunk),(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.WA)(queryThunk)),((draft,action)=>{const providedTags=calculateProvidedByThunk(action,"providesTags",definitions,assertTagType),{queryCacheKey}=action.meta.arg;invalidationSlice.caseReducers.updateProvidedBy(draft,invalidationSlice.actions.updateProvidedBy({queryCacheKey,providedTags}))}))}}),subscriptionSlice=(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.Z0)({name:`${reducerPath}/subscriptions`,initialState,reducers:{updateSubscriptionOptions(d,a){},unsubscribeQueryResult(d,a){},internal_getRTKQSubscriptions(){}}}),internalSubscriptionsSlice=(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.Z0)({name:`${reducerPath}/internalSubscriptions`,initialState,reducers:{subscriptionsUpdated:{reducer:(state,action)=>(0,immer__WEBPACK_IMPORTED_MODULE_2__.$i)(state,action.payload),prepare:(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.aA)()}}}),configSlice=(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.Z0)({name:`${reducerPath}/config`,initialState:{online:"undefined"==typeof navigator||void 0===navigator.onLine||navigator.onLine,focused:"undefined"==typeof document||"hidden"!==document.visibilityState,middlewareRegistered:!1,...config},reducers:{middlewareRegistered(state,{payload}){state.middlewareRegistered="conflict"!==state.middlewareRegistered&&apiUid===payload||"conflict"}},extraReducers:builder=>{builder.addCase(onOnline,(state=>{state.online=!0})).addCase(onOffline,(state=>{state.online=!1})).addCase(onFocus,(state=>{state.focused=!0})).addCase(onFocusLost,(state=>{state.focused=!1})).addMatcher(hasRehydrationInfo,(draft=>({...draft})))}}),combinedReducer=(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.HY)({queries:querySlice.reducer,mutations:mutationSlice.reducer,provided:invalidationSlice.reducer,subscriptions:internalSubscriptionsSlice.reducer,config:configSlice.reducer});return{reducer:(state,action)=>combinedReducer(resetApiState.match(action)?void 0:state,action),actions:{...configSlice.actions,...querySlice.actions,...subscriptionSlice.actions,...internalSubscriptionsSlice.actions,...mutationSlice.actions,...invalidationSlice.actions,resetApiState}}}var skipToken=Symbol.for("RTKQ/skipToken"),initialSubState={status:"uninitialized"},defaultQuerySubState=(0,immer__WEBPACK_IMPORTED_MODULE_2__.jM)(initialSubState,(()=>{})),defaultMutationSubState=(0,immer__WEBPACK_IMPORTED_MODULE_2__.jM)(initialSubState,(()=>{}));var cache=WeakMap?new WeakMap:void 0,defaultSerializeQueryArgs=({endpointName,queryArgs})=>{let serialized="";const cached=cache?.get(queryArgs);if("string"==typeof cached)serialized=cached;else{const stringified=JSON.stringify(queryArgs,((key,value)=>(value="bigint"==typeof value?{$bigint:value.toString()}:value,value=(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.Qd)(value)?Object.keys(value).sort().reduce(((acc,key2)=>(acc[key2]=value[key2],acc)),{}):value)));(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.Qd)(queryArgs)&&cache?.set(queryArgs,stringified),serialized=stringified}return`${endpointName}(${serialized})`};function buildCreateApi(...modules){return function baseCreateApi(options){const extractRehydrationInfo=(0,reselect__WEBPACK_IMPORTED_MODULE_3__.X4)((action=>options.extractRehydrationInfo?.(action,{reducerPath:options.reducerPath??"api"}))),optionsWithDefaults={reducerPath:"api",keepUnusedDataFor:60,refetchOnMountOrArgChange:!1,refetchOnFocus:!1,refetchOnReconnect:!1,invalidationBehavior:"delayed",...options,extractRehydrationInfo,serializeQueryArgs(queryArgsApi){let finalSerializeQueryArgs=defaultSerializeQueryArgs;if("serializeQueryArgs"in queryArgsApi.endpointDefinition){const endpointSQA=queryArgsApi.endpointDefinition.serializeQueryArgs;finalSerializeQueryArgs=queryArgsApi2=>{const initialResult=endpointSQA(queryArgsApi2);return"string"==typeof initialResult?initialResult:defaultSerializeQueryArgs({...queryArgsApi2,queryArgs:initialResult})}}else options.serializeQueryArgs&&(finalSerializeQueryArgs=options.serializeQueryArgs);return finalSerializeQueryArgs(queryArgsApi)},tagTypes:[...options.tagTypes||[]]},context={endpointDefinitions:{},batch(fn){fn()},apiUid:(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.Ak)(),extractRehydrationInfo,hasRehydrationInfo:(0,reselect__WEBPACK_IMPORTED_MODULE_3__.X4)((action=>null!=extractRehydrationInfo(action)))},api={injectEndpoints:function injectEndpoints(inject){const evaluatedEndpoints=inject.endpoints({query:x=>({...x,type:"query"}),mutation:x=>({...x,type:"mutation"})});for(const[endpointName,definition]of Object.entries(evaluatedEndpoints))if(!0!==inject.overrideExisting&&endpointName in context.endpointDefinitions){if("throw"===inject.overrideExisting)throw new Error((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.gk)(39))}else{context.endpointDefinitions[endpointName]=definition;for(const m of initializedModules)m.injectEndpoint(endpointName,definition)}return api},enhanceEndpoints({addTagTypes,endpoints}){if(addTagTypes)for(const eT of addTagTypes)optionsWithDefaults.tagTypes.includes(eT)||optionsWithDefaults.tagTypes.push(eT);if(endpoints)for(const[endpointName,partialDefinition]of Object.entries(endpoints))"function"==typeof partialDefinition?partialDefinition(context.endpointDefinitions[endpointName]):Object.assign(context.endpointDefinitions[endpointName]||{},partialDefinition);return api}},initializedModules=modules.map((m=>m.init(api,optionsWithDefaults,context)));return api.injectEndpoints({endpoints:options.endpoints})}}function safeAssign(target,...args){return Object.assign(target,...args)}var buildBatchedActionsHandler=({api,queryThunk,internalState})=>{const subscriptionsPrefix=`${api.reducerPath}/subscriptions`;let previousSubscriptions=null,updateSyncTimer=null;const{updateSubscriptionOptions,unsubscribeQueryResult}=api.internalActions,getSubscriptions=()=>internalState.currentSubscriptions,subscriptionSelectors={getSubscriptions,getSubscriptionCount:queryCacheKey=>countObjectKeys(getSubscriptions()[queryCacheKey]??{}),isRequestSubscribed:(queryCacheKey,requestId)=>{const subscriptions=getSubscriptions();return!!subscriptions?.[queryCacheKey]?.[requestId]}};return(action,mwApi)=>{if(previousSubscriptions||(previousSubscriptions=JSON.parse(JSON.stringify(internalState.currentSubscriptions))),api.util.resetApiState.match(action))return previousSubscriptions=internalState.currentSubscriptions={},updateSyncTimer=null,[!0,!1];if(api.internalActions.internal_getRTKQSubscriptions.match(action))return[!1,subscriptionSelectors];const didMutate=((mutableState,action)=>{if(updateSubscriptionOptions.match(action)){const{queryCacheKey,requestId,options}=action.payload;return mutableState?.[queryCacheKey]?.[requestId]&&(mutableState[queryCacheKey][requestId]=options),!0}if(unsubscribeQueryResult.match(action)){const{queryCacheKey,requestId}=action.payload;return mutableState[queryCacheKey]&&delete mutableState[queryCacheKey][requestId],!0}if(api.internalActions.removeQueryResult.match(action))return delete mutableState[action.payload.queryCacheKey],!0;if(queryThunk.pending.match(action)){const{meta:{arg,requestId}}=action,substate=mutableState[arg.queryCacheKey]??={};return substate[`${requestId}_running`]={},arg.subscribe&&(substate[requestId]=arg.subscriptionOptions??substate[requestId]??{}),!0}let mutated=!1;if(queryThunk.fulfilled.match(action)||queryThunk.rejected.match(action)){const state=mutableState[action.meta.arg.queryCacheKey]||{},key=`${action.meta.requestId}_running`;mutated||=!!state[key],delete state[key]}if(queryThunk.rejected.match(action)){const{meta:{condition,arg,requestId}}=action;if(condition&&arg.subscribe){const substate=mutableState[arg.queryCacheKey]??={};substate[requestId]=arg.subscriptionOptions??substate[requestId]??{},mutated=!0}}return mutated})(internalState.currentSubscriptions,action);let actionShouldContinue=!0;if(didMutate){updateSyncTimer||(updateSyncTimer=setTimeout((()=>{const newSubscriptions=JSON.parse(JSON.stringify(internalState.currentSubscriptions)),[,patches]=(0,immer__WEBPACK_IMPORTED_MODULE_2__.vI)(previousSubscriptions,(()=>newSubscriptions));mwApi.next(api.internalActions.subscriptionsUpdated(patches)),previousSubscriptions=newSubscriptions,updateSyncTimer=null}),500));const isSubscriptionSliceAction="string"==typeof action.type&&!!action.type.startsWith(subscriptionsPrefix),isAdditionalSubscriptionAction=queryThunk.rejected.match(action)&&action.meta.condition&&!!action.meta.arg.subscribe;actionShouldContinue=!isSubscriptionSliceAction&&!isAdditionalSubscriptionAction}return[actionShouldContinue,!1]}};var buildCacheCollectionHandler=({reducerPath,api,queryThunk,context,internalState})=>{const{removeQueryResult,unsubscribeQueryResult,cacheEntriesUpserted}=api.internalActions,canTriggerUnsubscribe=(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.i0)(unsubscribeQueryResult.match,queryThunk.fulfilled,queryThunk.rejected,cacheEntriesUpserted.match);function anySubscriptionsRemainingForKey(queryCacheKey){const subscriptions=internalState.currentSubscriptions[queryCacheKey];return!!subscriptions&&!function isObjectEmpty(obj){for(const k in obj)return!1;return!0}(subscriptions)}const currentRemovalTimeouts={};function handleUnsubscribe(queryCacheKey,endpointName,api2,config){const endpointDefinition=context.endpointDefinitions[endpointName],keepUnusedDataFor=endpointDefinition?.keepUnusedDataFor??config.keepUnusedDataFor;if(keepUnusedDataFor===1/0)return;const finalKeepUnusedDataFor=Math.max(0,Math.min(keepUnusedDataFor,2147482.647));if(!anySubscriptionsRemainingForKey(queryCacheKey)){const currentTimeout=currentRemovalTimeouts[queryCacheKey];currentTimeout&&clearTimeout(currentTimeout),currentRemovalTimeouts[queryCacheKey]=setTimeout((()=>{anySubscriptionsRemainingForKey(queryCacheKey)||api2.dispatch(removeQueryResult({queryCacheKey})),delete currentRemovalTimeouts[queryCacheKey]}),1e3*finalKeepUnusedDataFor)}}return(action,mwApi,internalState2)=>{if(canTriggerUnsubscribe(action)){const state=mwApi.getState()[reducerPath];let queryCacheKeys;if(cacheEntriesUpserted.match(action))queryCacheKeys=action.payload.map((entry=>entry.queryDescription.queryCacheKey));else{const{queryCacheKey}=unsubscribeQueryResult.match(action)?action.payload:action.meta.arg;queryCacheKeys=[queryCacheKey]}for(const queryCacheKey of queryCacheKeys)handleUnsubscribe(queryCacheKey,state.queries[queryCacheKey]?.endpointName,mwApi,state.config)}if(api.util.resetApiState.match(action))for(const[key,timeout]of Object.entries(currentRemovalTimeouts))timeout&&clearTimeout(timeout),delete currentRemovalTimeouts[key];if(context.hasRehydrationInfo(action)){const state=mwApi.getState()[reducerPath],{queries}=context.extractRehydrationInfo(action);for(const[queryCacheKey,queryState]of Object.entries(queries))handleUnsubscribe(queryCacheKey,queryState?.endpointName,mwApi,state.config)}}},neverResolvedError=new Error("Promise never resolved before cacheEntryRemoved."),buildCacheLifecycleHandler=({api,reducerPath,context,queryThunk,mutationThunk,internalState})=>{const isQueryThunk=(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.$S)(queryThunk),isMutationThunk=(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.$S)(mutationThunk),isFulfilledThunk=(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.sf)(queryThunk,mutationThunk),lifecycleMap={};function resolveLifecycleEntry(cacheKey,data,meta){const lifecycle=lifecycleMap[cacheKey];lifecycle?.valueResolved&&(lifecycle.valueResolved({data,meta}),delete lifecycle.valueResolved)}function removeLifecycleEntry(cacheKey){const lifecycle=lifecycleMap[cacheKey];lifecycle&&(delete lifecycleMap[cacheKey],lifecycle.cacheEntryRemoved())}function handleNewKey(endpointName,originalArgs,queryCacheKey,mwApi,requestId){const endpointDefinition=context.endpointDefinitions[endpointName],onCacheEntryAdded=endpointDefinition?.onCacheEntryAdded;if(!onCacheEntryAdded)return;const lifecycle={},cacheEntryRemoved=new Promise((resolve=>{lifecycle.cacheEntryRemoved=resolve})),cacheDataLoaded=Promise.race([new Promise((resolve=>{lifecycle.valueResolved=resolve})),cacheEntryRemoved.then((()=>{throw neverResolvedError}))]);cacheDataLoaded.catch((()=>{})),lifecycleMap[queryCacheKey]=lifecycle;const selector=api.endpoints[endpointName].select("query"===endpointDefinition.type?originalArgs:queryCacheKey),extra=mwApi.dispatch(((_,__,extra2)=>extra2)),lifecycleApi={...mwApi,getCacheEntry:()=>selector(mwApi.getState()),requestId,extra,updateCachedData:"query"===endpointDefinition.type?updateRecipe=>mwApi.dispatch(api.util.updateQueryData(endpointName,originalArgs,updateRecipe)):void 0,cacheDataLoaded,cacheEntryRemoved},runningHandler=onCacheEntryAdded(originalArgs,lifecycleApi);Promise.resolve(runningHandler).catch((e=>{if(e!==neverResolvedError)throw e}))}return(action,mwApi,stateBefore)=>{const cacheKey=function getCacheKey(action){if(isQueryThunk(action))return action.meta.arg.queryCacheKey;if(isMutationThunk(action))return action.meta.arg.fixedCacheKey??action.meta.requestId;return api.internalActions.removeQueryResult.match(action)?action.payload.queryCacheKey:api.internalActions.removeMutationResult.match(action)?getMutationCacheKey(action.payload):""}(action);function checkForNewCacheKey(endpointName,cacheKey2,requestId,originalArgs){const oldState=stateBefore[reducerPath].queries[cacheKey2],state=mwApi.getState()[reducerPath].queries[cacheKey2];!oldState&&state&&handleNewKey(endpointName,originalArgs,cacheKey2,mwApi,requestId)}if(queryThunk.pending.match(action))checkForNewCacheKey(action.meta.arg.endpointName,cacheKey,action.meta.requestId,action.meta.arg.originalArgs);else if(api.internalActions.cacheEntriesUpserted.match(action))for(const{queryDescription,value}of action.payload){const{endpointName,originalArgs,queryCacheKey}=queryDescription;checkForNewCacheKey(endpointName,queryCacheKey,action.meta.requestId,originalArgs),resolveLifecycleEntry(queryCacheKey,value,{})}else if(mutationThunk.pending.match(action)){mwApi.getState()[reducerPath].mutations[cacheKey]&&handleNewKey(action.meta.arg.endpointName,action.meta.arg.originalArgs,cacheKey,mwApi,action.meta.requestId)}else if(isFulfilledThunk(action))resolveLifecycleEntry(cacheKey,action.payload,action.meta.baseQueryMeta);else if(api.internalActions.removeQueryResult.match(action)||api.internalActions.removeMutationResult.match(action))removeLifecycleEntry(cacheKey);else if(api.util.resetApiState.match(action))for(const cacheKey2 of Object.keys(lifecycleMap))removeLifecycleEntry(cacheKey2)}},buildDevCheckHandler=({api,context:{apiUid},reducerPath})=>(action,mwApi)=>{api.util.resetApiState.match(action)&&mwApi.dispatch(api.internalActions.middlewareRegistered(apiUid))},buildInvalidationByTagsHandler=({reducerPath,context,context:{endpointDefinitions},mutationThunk,queryThunk,api,assertTagType,refetchQuery,internalState})=>{const{removeQueryResult}=api.internalActions,isThunkActionWithTags=(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.i0)((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.sf)(mutationThunk),(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.WA)(mutationThunk)),isQueryEnd=(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.i0)((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.sf)(mutationThunk,queryThunk),(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.TK)(mutationThunk,queryThunk));let pendingTagInvalidations=[];function invalidateTags(newTags,mwApi){const rootState=mwApi.getState(),state=rootState[reducerPath];if(pendingTagInvalidations.push(...newTags),"delayed"===state.config.invalidationBehavior&&function hasPendingRequests(state){for(const key in state.queries)if("pending"===state.queries[key]?.status)return!0;for(const key in state.mutations)if("pending"===state.mutations[key]?.status)return!0;return!1}(state))return;const tags=pendingTagInvalidations;if(pendingTagInvalidations=[],0===tags.length)return;const toInvalidate=api.util.selectInvalidatedBy(rootState,tags);context.batch((()=>{const valuesArray=Array.from(toInvalidate.values());for(const{queryCacheKey}of valuesArray){const querySubState=state.queries[queryCacheKey],subscriptionSubState=internalState.currentSubscriptions[queryCacheKey]??{};querySubState&&(0===countObjectKeys(subscriptionSubState)?mwApi.dispatch(removeQueryResult({queryCacheKey})):"uninitialized"!==querySubState.status&&mwApi.dispatch(refetchQuery(querySubState)))}}))}return(action,mwApi)=>{isThunkActionWithTags(action)?invalidateTags(calculateProvidedByThunk(action,"invalidatesTags",endpointDefinitions,assertTagType),mwApi):isQueryEnd(action)?invalidateTags([],mwApi):api.util.invalidateTags.match(action)&&invalidateTags(calculateProvidedBy(action.payload,void 0,void 0,void 0,void 0,assertTagType),mwApi)}},buildPollingHandler=({reducerPath,queryThunk,api,refetchQuery,internalState})=>{const currentPolls={};function startNextPoll({queryCacheKey},api2){const state=api2.getState()[reducerPath],querySubState=state.queries[queryCacheKey],subscriptions=internalState.currentSubscriptions[queryCacheKey];if(!querySubState||"uninitialized"===querySubState.status)return;const{lowestPollingInterval,skipPollingIfUnfocused}=findLowestPollingInterval(subscriptions);if(!Number.isFinite(lowestPollingInterval))return;const currentPoll=currentPolls[queryCacheKey];currentPoll?.timeout&&(clearTimeout(currentPoll.timeout),currentPoll.timeout=void 0);const nextPollTimestamp=Date.now()+lowestPollingInterval;currentPolls[queryCacheKey]={nextPollTimestamp,pollingInterval:lowestPollingInterval,timeout:setTimeout((()=>{!state.config.focused&&skipPollingIfUnfocused||api2.dispatch(refetchQuery(querySubState)),startNextPoll({queryCacheKey},api2)}),lowestPollingInterval)}}function updatePollingInterval({queryCacheKey},api2){const querySubState=api2.getState()[reducerPath].queries[queryCacheKey],subscriptions=internalState.currentSubscriptions[queryCacheKey];if(!querySubState||"uninitialized"===querySubState.status)return;const{lowestPollingInterval}=findLowestPollingInterval(subscriptions);if(!Number.isFinite(lowestPollingInterval))return void cleanupPollForKey(queryCacheKey);const currentPoll=currentPolls[queryCacheKey],nextPollTimestamp=Date.now()+lowestPollingInterval;(!currentPoll||nextPollTimestamp<currentPoll.nextPollTimestamp)&&startNextPoll({queryCacheKey},api2)}function cleanupPollForKey(key){const existingPoll=currentPolls[key];existingPoll?.timeout&&clearTimeout(existingPoll.timeout),delete currentPolls[key]}function findLowestPollingInterval(subscribers={}){let skipPollingIfUnfocused=!1,lowestPollingInterval=Number.POSITIVE_INFINITY;for(let key in subscribers)subscribers[key].pollingInterval&&(lowestPollingInterval=Math.min(subscribers[key].pollingInterval,lowestPollingInterval),skipPollingIfUnfocused=subscribers[key].skipPollingIfUnfocused||skipPollingIfUnfocused);return{lowestPollingInterval,skipPollingIfUnfocused}}return(action,mwApi)=>{(api.internalActions.updateSubscriptionOptions.match(action)||api.internalActions.unsubscribeQueryResult.match(action))&&updatePollingInterval(action.payload,mwApi),(queryThunk.pending.match(action)||queryThunk.rejected.match(action)&&action.meta.condition)&&updatePollingInterval(action.meta.arg,mwApi),(queryThunk.fulfilled.match(action)||queryThunk.rejected.match(action)&&!action.meta.condition)&&startNextPoll(action.meta.arg,mwApi),api.util.resetApiState.match(action)&&function clearPolls(){for(const key of Object.keys(currentPolls))cleanupPollForKey(key)}()}},buildQueryLifecycleHandler=({api,context,queryThunk,mutationThunk})=>{const isPendingThunk=(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.mm)(queryThunk,mutationThunk),isRejectedThunk=(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.TK)(queryThunk,mutationThunk),isFullfilledThunk=(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.sf)(queryThunk,mutationThunk),lifecycleMap={};return(action,mwApi)=>{if(isPendingThunk(action)){const{requestId,arg:{endpointName,originalArgs}}=action.meta,endpointDefinition=context.endpointDefinitions[endpointName],onQueryStarted=endpointDefinition?.onQueryStarted;if(onQueryStarted){const lifecycle={},queryFulfilled=new Promise(((resolve,reject)=>{lifecycle.resolve=resolve,lifecycle.reject=reject}));queryFulfilled.catch((()=>{})),lifecycleMap[requestId]=lifecycle;const selector=api.endpoints[endpointName].select("query"===endpointDefinition.type?originalArgs:requestId),extra=mwApi.dispatch(((_,__,extra2)=>extra2)),lifecycleApi={...mwApi,getCacheEntry:()=>selector(mwApi.getState()),requestId,extra,updateCachedData:"query"===endpointDefinition.type?updateRecipe=>mwApi.dispatch(api.util.updateQueryData(endpointName,originalArgs,updateRecipe)):void 0,queryFulfilled};onQueryStarted(originalArgs,lifecycleApi)}}else if(isFullfilledThunk(action)){const{requestId,baseQueryMeta}=action.meta;lifecycleMap[requestId]?.resolve({data:action.payload,meta:baseQueryMeta}),delete lifecycleMap[requestId]}else if(isRejectedThunk(action)){const{requestId,rejectedWithValue,baseQueryMeta}=action.meta;lifecycleMap[requestId]?.reject({error:action.payload??action.error,isUnhandledError:!rejectedWithValue,meta:baseQueryMeta}),delete lifecycleMap[requestId]}}};function buildMiddleware(input){const{reducerPath,queryThunk,api,context}=input,{apiUid}=context,actions={invalidateTags:(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.VP)(`${reducerPath}/invalidateTags`)},isThisApiSliceAction=action=>action.type.startsWith(`${reducerPath}/`),handlerBuilders=[buildDevCheckHandler,buildCacheCollectionHandler,buildInvalidationByTagsHandler,buildPollingHandler,buildCacheLifecycleHandler,buildQueryLifecycleHandler];return{middleware:mwApi=>{let initialized2=!1;const builderArgs={...input,internalState:{currentSubscriptions:{}},refetchQuery,isThisApiSliceAction},handlers=handlerBuilders.map((build=>build(builderArgs))),batchedActionsHandler=buildBatchedActionsHandler(builderArgs),windowEventsHandler=(({reducerPath,context,api,refetchQuery,internalState})=>{const{removeQueryResult}=api.internalActions;function refetchValidQueries(api2,type){const state=api2.getState()[reducerPath],queries=state.queries,subscriptions=internalState.currentSubscriptions;context.batch((()=>{for(const queryCacheKey of Object.keys(subscriptions)){const querySubState=queries[queryCacheKey],subscriptionSubState=subscriptions[queryCacheKey];subscriptionSubState&&querySubState&&((Object.values(subscriptionSubState).some((sub=>!0===sub[type]))||Object.values(subscriptionSubState).every((sub=>void 0===sub[type]))&&state.config[type])&&(0===countObjectKeys(subscriptionSubState)?api2.dispatch(removeQueryResult({queryCacheKey})):"uninitialized"!==querySubState.status&&api2.dispatch(refetchQuery(querySubState))))}}))}return(action,mwApi)=>{onFocus.match(action)&&refetchValidQueries(mwApi,"refetchOnFocus"),onOnline.match(action)&&refetchValidQueries(mwApi,"refetchOnReconnect")}})(builderArgs);return next=>action=>{if(!(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.ve)(action))return next(action);initialized2||(initialized2=!0,mwApi.dispatch(api.internalActions.middlewareRegistered(apiUid)));const mwApiWithNext={...mwApi,next},stateBefore=mwApi.getState(),[actionShouldContinue,internalProbeResult]=batchedActionsHandler(action,mwApiWithNext,stateBefore);let res;if(res=actionShouldContinue?next(action):internalProbeResult,mwApi.getState()[reducerPath]&&(windowEventsHandler(action,mwApiWithNext,stateBefore),isThisApiSliceAction(action)||context.hasRehydrationInfo(action)))for(const handler of handlers)handler(action,mwApiWithNext,stateBefore);return res}},actions};function refetchQuery(querySubState){return input.api.endpoints[querySubState.endpointName].initiate(querySubState.originalArgs,{subscribe:!1,forceRefetch:!0})}}var coreModuleName=Symbol(),coreModule=({createSelector:createSelector2=reselect__WEBPACK_IMPORTED_MODULE_3__.Mz}={})=>({name:coreModuleName,init(api,{baseQuery,tagTypes,reducerPath,serializeQueryArgs,keepUnusedDataFor,refetchOnMountOrArgChange,refetchOnFocus,refetchOnReconnect,invalidationBehavior},context){(0,immer__WEBPACK_IMPORTED_MODULE_2__.YT)();const assertTagType=tag=>tag;Object.assign(api,{reducerPath,endpoints:{},internalActions:{onOnline,onOffline,onFocus,onFocusLost},util:{}});const{queryThunk,mutationThunk,patchQueryData,updateQueryData,upsertQueryData,prefetch,buildMatchThunkActions}=function buildThunks({reducerPath,baseQuery,context:{endpointDefinitions},serializeQueryArgs,api,assertTagType}){const executeEndpoint=async(arg,{signal,abort,rejectWithValue,fulfillWithValue,dispatch,getState,extra})=>{const endpointDefinition=endpointDefinitions[arg.endpointName];try{let result,transformResponse=defaultTransformResponse;const baseQueryApi={signal,abort,dispatch,getState,extra,endpoint:arg.endpointName,type:arg.type,forced:"query"===arg.type?isForcedQuery(arg,getState()):void 0,queryCacheKey:"query"===arg.type?arg.queryCacheKey:void 0},forceQueryFn="query"===arg.type?arg[forceQueryFnSymbol]:void 0;if(forceQueryFn?result=forceQueryFn():endpointDefinition.query?(result=await baseQuery(endpointDefinition.query(arg.originalArgs),baseQueryApi,endpointDefinition.extraOptions),endpointDefinition.transformResponse&&(transformResponse=endpointDefinition.transformResponse)):result=await endpointDefinition.queryFn(arg.originalArgs,baseQueryApi,endpointDefinition.extraOptions,(arg2=>baseQuery(arg2,baseQueryApi,endpointDefinition.extraOptions))),result.error)throw new HandledError(result.error,result.meta);return fulfillWithValue(await transformResponse(result.data,result.meta,arg.originalArgs),{fulfilledTimeStamp:Date.now(),baseQueryMeta:result.meta,[_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.cN]:!0})}catch(error){let catchedError=error;if(catchedError instanceof HandledError){let transformErrorResponse=defaultTransformResponse;endpointDefinition.query&&endpointDefinition.transformErrorResponse&&(transformErrorResponse=endpointDefinition.transformErrorResponse);try{return rejectWithValue(await transformErrorResponse(catchedError.value,catchedError.meta,arg.originalArgs),{baseQueryMeta:catchedError.meta,[_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.cN]:!0})}catch(e){catchedError=e}}throw console.error(catchedError),catchedError}};function isForcedQuery(arg,state){const requestState=state[reducerPath]?.queries?.[arg.queryCacheKey],baseFetchOnMountOrArgChange=state[reducerPath]?.config.refetchOnMountOrArgChange,fulfilledVal=requestState?.fulfilledTimeStamp,refetchVal=arg.forceRefetch??(arg.subscribe&&baseFetchOnMountOrArgChange);return!!refetchVal&&(!0===refetchVal||(Number(new Date)-Number(fulfilledVal))/1e3>=refetchVal)}const queryThunk=(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.zD)(`${reducerPath}/executeQuery`,executeEndpoint,{getPendingMeta:()=>({startedTimeStamp:Date.now(),[_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.cN]:!0}),condition(queryThunkArgs,{getState}){const state=getState(),requestState=state[reducerPath]?.queries?.[queryThunkArgs.queryCacheKey],fulfilledVal=requestState?.fulfilledTimeStamp,currentArg=queryThunkArgs.originalArgs,previousArg=requestState?.originalArgs,endpointDefinition=endpointDefinitions[queryThunkArgs.endpointName];return!(!isUpsertQuery(queryThunkArgs)&&("pending"===requestState?.status||!isForcedQuery(queryThunkArgs,state)&&(!isQueryDefinition(endpointDefinition)||!endpointDefinition?.forceRefetch?.({currentArg,previousArg,endpointState:requestState,state}))&&fulfilledVal))},dispatchConditionRejection:!0}),mutationThunk=(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.zD)(`${reducerPath}/executeMutation`,executeEndpoint,{getPendingMeta:()=>({startedTimeStamp:Date.now(),[_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.cN]:!0})});function matchesEndpoint(endpointName){return action=>action?.meta?.arg?.endpointName===endpointName}return{queryThunk,mutationThunk,prefetch:(endpointName,arg,options)=>(dispatch,getState)=>{const force=(options=>"force"in options)(options)&&options.force,maxAge=(options=>"ifOlderThan"in options)(options)&&options.ifOlderThan,queryAction=(force2=!0)=>{const options2={forceRefetch:force2,isPrefetch:!0};return api.endpoints[endpointName].initiate(arg,options2)},latestStateValue=api.endpoints[endpointName].select(arg)(getState());if(force)dispatch(queryAction());else if(maxAge){const lastFulfilledTs=latestStateValue?.fulfilledTimeStamp;if(!lastFulfilledTs)return void dispatch(queryAction());(Number(new Date)-Number(new Date(lastFulfilledTs)))/1e3>=maxAge&&dispatch(queryAction())}else dispatch(queryAction(!1))},updateQueryData:(endpointName,arg,updateRecipe,updateProvided=!0)=>(dispatch,getState)=>{const currentState=api.endpoints[endpointName].select(arg)(getState()),ret={patches:[],inversePatches:[],undo:()=>dispatch(api.util.patchQueryData(endpointName,arg,ret.inversePatches,updateProvided))};if("uninitialized"===currentState.status)return ret;let newValue;if("data"in currentState)if((0,immer__WEBPACK_IMPORTED_MODULE_2__.a6)(currentState.data)){const[value,patches,inversePatches]=(0,immer__WEBPACK_IMPORTED_MODULE_2__.vI)(currentState.data,updateRecipe);ret.patches.push(...patches),ret.inversePatches.push(...inversePatches),newValue=value}else newValue=updateRecipe(currentState.data),ret.patches.push({op:"replace",path:[],value:newValue}),ret.inversePatches.push({op:"replace",path:[],value:currentState.data});return 0===ret.patches.length||dispatch(api.util.patchQueryData(endpointName,arg,ret.patches,updateProvided)),ret},upsertQueryData:(endpointName,arg,value)=>dispatch=>dispatch(api.endpoints[endpointName].initiate(arg,{subscribe:!1,forceRefetch:!0,[forceQueryFnSymbol]:()=>({data:value})})),patchQueryData:(endpointName,arg,patches,updateProvided)=>(dispatch,getState)=>{const endpointDefinition=endpointDefinitions[endpointName],queryCacheKey=serializeQueryArgs({queryArgs:arg,endpointDefinition,endpointName});if(dispatch(api.internalActions.queryResultPatched({queryCacheKey,patches})),!updateProvided)return;const newValue=api.endpoints[endpointName].select(arg)(getState()),providedTags=calculateProvidedBy(endpointDefinition.providesTags,newValue.data,void 0,arg,{},assertTagType);dispatch(api.internalActions.updateProvidedBy({queryCacheKey,providedTags}))},buildMatchThunkActions:function buildMatchThunkActions(thunk,endpointName){return{matchPending:(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.f$)((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.mm)(thunk),matchesEndpoint(endpointName)),matchFulfilled:(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.f$)((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.sf)(thunk),matchesEndpoint(endpointName)),matchRejected:(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.f$)((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.TK)(thunk),matchesEndpoint(endpointName))}}}}({baseQuery,reducerPath,context,api,serializeQueryArgs,assertTagType}),{reducer,actions:sliceActions}=buildSlice({context,queryThunk,mutationThunk,serializeQueryArgs,reducerPath,assertTagType,config:{refetchOnFocus,refetchOnReconnect,refetchOnMountOrArgChange,keepUnusedDataFor,reducerPath,invalidationBehavior}});safeAssign(api.util,{patchQueryData,updateQueryData,upsertQueryData,prefetch,resetApiState:sliceActions.resetApiState,upsertQueryEntries:sliceActions.cacheEntriesUpserted}),safeAssign(api.internalActions,sliceActions);const{middleware,actions:middlewareActions}=buildMiddleware({reducerPath,context,queryThunk,mutationThunk,api,assertTagType});safeAssign(api.util,middlewareActions),safeAssign(api,{reducer,middleware});const{buildQuerySelector,buildMutationSelector,selectInvalidatedBy,selectCachedArgsForQuery}=function buildSelectors({serializeQueryArgs,reducerPath,createSelector:createSelector2}){const selectSkippedQuery=state=>defaultQuerySubState,selectSkippedMutation=state=>defaultMutationSubState;return{buildQuerySelector:function buildQuerySelector(endpointName,endpointDefinition){return queryArgs=>{if(queryArgs===skipToken)return createSelector2(selectSkippedQuery,withRequestFlags);const serializedArgs=serializeQueryArgs({queryArgs,endpointDefinition,endpointName});return createSelector2((state=>selectInternalState(state)?.queries?.[serializedArgs]??defaultQuerySubState),withRequestFlags)}},buildMutationSelector:function buildMutationSelector(){return id=>{let mutationId;return mutationId="object"==typeof id?getMutationCacheKey(id)??skipToken:id,createSelector2(mutationId===skipToken?selectSkippedMutation:state=>selectInternalState(state)?.mutations?.[mutationId]??defaultMutationSubState,withRequestFlags)}},selectInvalidatedBy:function selectInvalidatedBy(state,tags){const apiState=state[reducerPath],toInvalidate=new Set;for(const tag of tags.filter(isNotNullish).map(expandTagDescription)){const provided=apiState.provided[tag.type];if(!provided)continue;let invalidateSubscriptions=(void 0!==tag.id?provided[tag.id]:flatten(Object.values(provided)))??[];for(const invalidate of invalidateSubscriptions)toInvalidate.add(invalidate)}return flatten(Array.from(toInvalidate.values()).map((queryCacheKey=>{const querySubState=apiState.queries[queryCacheKey];return querySubState?[{queryCacheKey,endpointName:querySubState.endpointName,originalArgs:querySubState.originalArgs}]:[]})))},selectCachedArgsForQuery:function selectCachedArgsForQuery(state,queryName){return Object.values(state[reducerPath].queries).filter((entry=>entry?.endpointName===queryName&&"uninitialized"!==entry.status)).map((entry=>entry.originalArgs))}};function withRequestFlags(substate){return{...substate,...(status=substate.status,{status,isUninitialized:"uninitialized"===status,isLoading:"pending"===status,isSuccess:"fulfilled"===status,isError:"rejected"===status})};var status}function selectInternalState(rootState){return rootState[reducerPath]}}({serializeQueryArgs,reducerPath,createSelector:createSelector2});safeAssign(api.util,{selectInvalidatedBy,selectCachedArgsForQuery});const{buildInitiateQuery,buildInitiateMutation,getRunningMutationThunk,getRunningMutationsThunk,getRunningQueriesThunk,getRunningQueryThunk}=function buildInitiate({serializeQueryArgs,queryThunk,mutationThunk,api,context}){const runningQueries=new Map,runningMutations=new Map,{unsubscribeQueryResult,removeMutationResult,updateSubscriptionOptions}=api.internalActions;return{buildInitiateQuery:function buildInitiateQuery(endpointName,endpointDefinition){const queryAction=(arg,{subscribe=!0,forceRefetch,subscriptionOptions,[forceQueryFnSymbol]:forceQueryFn,...rest}={})=>(dispatch,getState)=>{const queryCacheKey=serializeQueryArgs({queryArgs:arg,endpointDefinition,endpointName}),thunk=queryThunk({...rest,type:"query",subscribe,forceRefetch,subscriptionOptions,endpointName,originalArgs:arg,queryCacheKey,[forceQueryFnSymbol]:forceQueryFn}),selector=api.endpoints[endpointName].select(arg),thunkResult=dispatch(thunk),stateAfter=selector(getState());middlewareWarning(dispatch);const{requestId,abort}=thunkResult,skippedSynchronously=stateAfter.requestId!==requestId,runningQuery=runningQueries.get(dispatch)?.[queryCacheKey],selectFromState=()=>selector(getState()),statePromise=Object.assign(forceQueryFn?thunkResult.then(selectFromState):skippedSynchronously&&!runningQuery?Promise.resolve(stateAfter):Promise.all([runningQuery,thunkResult]).then(selectFromState),{arg,requestId,subscriptionOptions,queryCacheKey,abort,async unwrap(){const result=await statePromise;if(result.isError)throw result.error;return result.data},refetch:()=>dispatch(queryAction(arg,{subscribe:!1,forceRefetch:!0})),unsubscribe(){subscribe&&dispatch(unsubscribeQueryResult({queryCacheKey,requestId}))},updateSubscriptionOptions(options){statePromise.subscriptionOptions=options,dispatch(updateSubscriptionOptions({endpointName,requestId,queryCacheKey,options}))}});if(!runningQuery&&!skippedSynchronously&&!forceQueryFn){const running=function getOrInsert(map,key,value){return map.has(key)?map.get(key):map.set(key,value).get(key)}(runningQueries,dispatch,{});running[queryCacheKey]=statePromise,statePromise.then((()=>{delete running[queryCacheKey],countObjectKeys(running)||runningQueries.delete(dispatch)}))}return statePromise};return queryAction},buildInitiateMutation:function buildInitiateMutation(endpointName){return(arg,{track=!0,fixedCacheKey}={})=>(dispatch,getState)=>{const thunk=mutationThunk({type:"mutation",endpointName,originalArgs:arg,track,fixedCacheKey}),thunkResult=dispatch(thunk);middlewareWarning(dispatch);const{requestId,abort,unwrap}=thunkResult,returnValuePromise=function asSafePromise(promise,fallback){return promise.catch(fallback)}(thunkResult.unwrap().then((data=>({data}))),(error=>({error}))),ret=Object.assign(returnValuePromise,{arg:thunkResult.arg,requestId,abort,unwrap,reset:()=>{dispatch(removeMutationResult({requestId,fixedCacheKey}))}}),running=runningMutations.get(dispatch)||{};return runningMutations.set(dispatch,running),running[requestId]=ret,ret.then((()=>{delete running[requestId],countObjectKeys(running)||runningMutations.delete(dispatch)})),fixedCacheKey&&(running[fixedCacheKey]=ret,ret.then((()=>{running[fixedCacheKey]===ret&&(delete running[fixedCacheKey],countObjectKeys(running)||runningMutations.delete(dispatch))}))),ret}},getRunningQueryThunk:function getRunningQueryThunk(endpointName,queryArgs){return dispatch=>{const endpointDefinition=context.endpointDefinitions[endpointName],queryCacheKey=serializeQueryArgs({queryArgs,endpointDefinition,endpointName});return runningQueries.get(dispatch)?.[queryCacheKey]}},getRunningMutationThunk:function getRunningMutationThunk(_endpointName,fixedCacheKeyOrRequestId){return dispatch=>runningMutations.get(dispatch)?.[fixedCacheKeyOrRequestId]},getRunningQueriesThunk:function getRunningQueriesThunk(){return dispatch=>Object.values(runningQueries.get(dispatch)||{}).filter(isNotNullish)},getRunningMutationsThunk:function getRunningMutationsThunk(){return dispatch=>Object.values(runningMutations.get(dispatch)||{}).filter(isNotNullish)}};function middlewareWarning(dispatch){}}({queryThunk,mutationThunk,api,serializeQueryArgs,context});return safeAssign(api.util,{getRunningMutationThunk,getRunningMutationsThunk,getRunningQueryThunk,getRunningQueriesThunk}),{name:coreModuleName,injectEndpoint(endpointName,definition){const anyApi=api;anyApi.endpoints[endpointName]??={},isQueryDefinition(definition)?safeAssign(anyApi.endpoints[endpointName],{name:endpointName,select:buildQuerySelector(endpointName,definition),initiate:buildInitiateQuery(endpointName,definition)},buildMatchThunkActions(queryThunk,endpointName)):function isMutationDefinition(e){return"mutation"===e.type}(definition)&&safeAssign(anyApi.endpoints[endpointName],{name:endpointName,select:buildMutationSelector(),initiate:buildInitiateMutation(endpointName)},buildMatchThunkActions(mutationThunk,endpointName))}}}});coreModule()},"./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{cN:()=>SHOULD_AUTOBATCH,U1:()=>configureStore,VP:()=>createAction,zD:()=>createAsyncThunk,Nc:()=>createListenerMiddleware,Z0:()=>createSlice,gk:()=>formatProdErrorMessage,f$:()=>isAllOf,i0:()=>isAnyOf,$S:()=>isAsyncThunkAction,sf:()=>isFulfilled,mm:()=>isPending,TK:()=>isRejected,WA:()=>isRejectedWithValue,Ak:()=>nanoid,aA:()=>prepareAutoBatched});var redux=__webpack_require__("./node_modules/redux/dist/redux.mjs");function createThunkMiddleware(extraArgument){return({dispatch,getState})=>next=>action=>"function"==typeof action?action(dispatch,getState,extraArgument):next(action)}var redux_thunk_thunk=createThunkMiddleware(),withExtraArgument=createThunkMiddleware,immer=__webpack_require__("./node_modules/immer/dist/immer.mjs"),composeWithDevTools=(__webpack_require__("./node_modules/process/browser.js"),"undefined"!=typeof window&&window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__?window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__:function(){if(0!==arguments.length)return"object"==typeof arguments[0]?redux.Zz:redux.Zz.apply(null,arguments)}),hasMatchFunction=("undefined"!=typeof window&&window.__REDUX_DEVTOOLS_EXTENSION__&&window.__REDUX_DEVTOOLS_EXTENSION__,v=>v&&"function"==typeof v.match);function createAction(type,prepareAction){function actionCreator(...args){if(prepareAction){let prepared=prepareAction(...args);if(!prepared)throw new Error(formatProdErrorMessage(0));return{type,payload:prepared.payload,..."meta"in prepared&&{meta:prepared.meta},..."error"in prepared&&{error:prepared.error}}}return{type,payload:args[0]}}return actionCreator.toString=()=>`${type}`,actionCreator.type=type,actionCreator.match=action=>(0,redux.ve)(action)&&action.type===type,actionCreator}var Tuple=class _Tuple extends Array{constructor(...items){super(...items),Object.setPrototypeOf(this,_Tuple.prototype)}static get[Symbol.species](){return _Tuple}concat(...arr){return super.concat.apply(this,arr)}prepend(...arr){return 1===arr.length&&Array.isArray(arr[0])?new _Tuple(...arr[0].concat(this)):new _Tuple(...arr.concat(this))}};function freezeDraftable(val){return(0,immer.a6)(val)?(0,immer.jM)(val,(()=>{})):val}function getOrInsertComputed(map,key,compute){return map.has(key)?map.get(key):map.set(key,compute(key)).get(key)}var buildGetDefaultMiddleware=()=>function getDefaultMiddleware(options){const{thunk=!0,immutableCheck=!0,serializableCheck=!0,actionCreatorCheck=!0}=options??{};let middlewareArray=new Tuple;return thunk&&(!function isBoolean(x){return"boolean"==typeof x}(thunk)?middlewareArray.push(withExtraArgument(thunk.extraArgument)):middlewareArray.push(redux_thunk_thunk)),middlewareArray},SHOULD_AUTOBATCH="RTK_autoBatch",prepareAutoBatched=()=>payload=>({payload,meta:{[SHOULD_AUTOBATCH]:!0}}),createQueueWithTimer=timeout=>notify=>{setTimeout(notify,timeout)},buildGetDefaultEnhancers=middlewareEnhancer=>function getDefaultEnhancers(options){const{autoBatch=!0}=options??{};let enhancerArray=new Tuple(middlewareEnhancer);return autoBatch&&enhancerArray.push(((options={type:"raf"})=>next=>(...args)=>{const store=next(...args);let notifying=!0,shouldNotifyAtEndOfTick=!1,notificationQueued=!1;const listeners=new Set,queueCallback="tick"===options.type?queueMicrotask:"raf"===options.type?"undefined"!=typeof window&&window.requestAnimationFrame?window.requestAnimationFrame:createQueueWithTimer(10):"callback"===options.type?options.queueNotification:createQueueWithTimer(options.timeout),notifyListeners=()=>{notificationQueued=!1,shouldNotifyAtEndOfTick&&(shouldNotifyAtEndOfTick=!1,listeners.forEach((l=>l())))};return Object.assign({},store,{subscribe(listener2){const unsubscribe=store.subscribe((()=>notifying&&listener2()));return listeners.add(listener2),()=>{unsubscribe(),listeners.delete(listener2)}},dispatch(action){try{return notifying=!action?.meta?.[SHOULD_AUTOBATCH],shouldNotifyAtEndOfTick=!notifying,shouldNotifyAtEndOfTick&&(notificationQueued||(notificationQueued=!0,queueCallback(notifyListeners))),store.dispatch(action)}finally{notifying=!0}}})})("object"==typeof autoBatch?autoBatch:void 0)),enhancerArray};function configureStore(options){const getDefaultMiddleware=buildGetDefaultMiddleware(),{reducer,middleware,devTools=!0,preloadedState,enhancers}=options||{};let rootReducer,finalMiddleware;if("function"==typeof reducer)rootReducer=reducer;else{if(!(0,redux.Qd)(reducer))throw new Error(formatProdErrorMessage(1));rootReducer=(0,redux.HY)(reducer)}finalMiddleware="function"==typeof middleware?middleware(getDefaultMiddleware):getDefaultMiddleware();let finalCompose=redux.Zz;devTools&&(finalCompose=composeWithDevTools({trace:!1,..."object"==typeof devTools&&devTools}));const middlewareEnhancer=(0,redux.Tw)(...finalMiddleware),getDefaultEnhancers=buildGetDefaultEnhancers(middlewareEnhancer);const composedEnhancer=finalCompose(..."function"==typeof enhancers?enhancers(getDefaultEnhancers):getDefaultEnhancers());return(0,redux.y$)(rootReducer,preloadedState,composedEnhancer)}function executeReducerBuilderCallback(builderCallback){const actionsMap={},actionMatchers=[];let defaultCaseReducer;const builder={addCase(typeOrActionCreator,reducer){const type="string"==typeof typeOrActionCreator?typeOrActionCreator:typeOrActionCreator.type;if(!type)throw new Error(formatProdErrorMessage(28));if(type in actionsMap)throw new Error(formatProdErrorMessage(29));return actionsMap[type]=reducer,builder},addMatcher:(matcher,reducer)=>(actionMatchers.push({matcher,reducer}),builder),addDefaultCase:reducer=>(defaultCaseReducer=reducer,builder)};return builderCallback(builder),[actionsMap,actionMatchers,defaultCaseReducer]}var matches=(matcher,action)=>hasMatchFunction(matcher)?matcher.match(action):matcher(action);function isAnyOf(...matchers){return action=>matchers.some((matcher=>matches(matcher,action)))}function isAllOf(...matchers){return action=>matchers.every((matcher=>matches(matcher,action)))}function hasExpectedRequestMetadata(action,validStatus){if(!action||!action.meta)return!1;const hasValidRequestId="string"==typeof action.meta.requestId,hasValidRequestStatus=validStatus.indexOf(action.meta.requestStatus)>-1;return hasValidRequestId&&hasValidRequestStatus}function isAsyncThunkArray(a){return"function"==typeof a[0]&&"pending"in a[0]&&"fulfilled"in a[0]&&"rejected"in a[0]}function isPending(...asyncThunks){return 0===asyncThunks.length?action=>hasExpectedRequestMetadata(action,["pending"]):isAsyncThunkArray(asyncThunks)?isAnyOf(...asyncThunks.map((asyncThunk=>asyncThunk.pending))):isPending()(asyncThunks[0])}function isRejected(...asyncThunks){return 0===asyncThunks.length?action=>hasExpectedRequestMetadata(action,["rejected"]):isAsyncThunkArray(asyncThunks)?isAnyOf(...asyncThunks.map((asyncThunk=>asyncThunk.rejected))):isRejected()(asyncThunks[0])}function isRejectedWithValue(...asyncThunks){const hasFlag=action=>action&&action.meta&&action.meta.rejectedWithValue;return 0===asyncThunks.length||isAsyncThunkArray(asyncThunks)?isAllOf(isRejected(...asyncThunks),hasFlag):isRejectedWithValue()(asyncThunks[0])}function isFulfilled(...asyncThunks){return 0===asyncThunks.length?action=>hasExpectedRequestMetadata(action,["fulfilled"]):isAsyncThunkArray(asyncThunks)?isAnyOf(...asyncThunks.map((asyncThunk=>asyncThunk.fulfilled))):isFulfilled()(asyncThunks[0])}function isAsyncThunkAction(...asyncThunks){return 0===asyncThunks.length?action=>hasExpectedRequestMetadata(action,["pending","fulfilled","rejected"]):isAsyncThunkArray(asyncThunks)?isAnyOf(...asyncThunks.flatMap((asyncThunk=>[asyncThunk.pending,asyncThunk.rejected,asyncThunk.fulfilled]))):isAsyncThunkAction()(asyncThunks[0])}var nanoid=(size=21)=>{let id="",i=size;for(;i--;)id+="ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW"[64*Math.random()|0];return id},commonProperties=["name","message","stack","code"],RejectWithValue=class{constructor(payload,meta){this.payload=payload,this.meta=meta}_type},FulfillWithMeta=class{constructor(payload,meta){this.payload=payload,this.meta=meta}_type},miniSerializeError=value=>{if("object"==typeof value&&null!==value){const simpleError={};for(const property of commonProperties)"string"==typeof value[property]&&(simpleError[property]=value[property]);return simpleError}return{message:String(value)}},createAsyncThunk=(()=>{function createAsyncThunk2(typePrefix,payloadCreator,options){const fulfilled=createAction(typePrefix+"/fulfilled",((payload,requestId,arg,meta)=>({payload,meta:{...meta||{},arg,requestId,requestStatus:"fulfilled"}}))),pending=createAction(typePrefix+"/pending",((requestId,arg,meta)=>({payload:void 0,meta:{...meta||{},arg,requestId,requestStatus:"pending"}}))),rejected=createAction(typePrefix+"/rejected",((error,requestId,arg,payload,meta)=>({payload,error:(options&&options.serializeError||miniSerializeError)(error||"Rejected"),meta:{...meta||{},arg,requestId,rejectedWithValue:!!payload,requestStatus:"rejected",aborted:"AbortError"===error?.name,condition:"ConditionError"===error?.name}})));return Object.assign((function actionCreator(arg){return(dispatch,getState,extra)=>{const requestId=options?.idGenerator?options.idGenerator(arg):nanoid(),abortController=new AbortController;let abortHandler,abortReason;function abort(reason){abortReason=reason,abortController.abort()}const promise=async function(){let finalAction;try{let conditionResult=options?.condition?.(arg,{getState,extra});if(function isThenable(value){return null!==value&&"object"==typeof value&&"function"==typeof value.then}(conditionResult)&&(conditionResult=await conditionResult),!1===conditionResult||abortController.signal.aborted)throw{name:"ConditionError",message:"Aborted due to condition callback returning false."};const abortedPromise=new Promise(((_,reject)=>{abortHandler=()=>{reject({name:"AbortError",message:abortReason||"Aborted"})},abortController.signal.addEventListener("abort",abortHandler)}));dispatch(pending(requestId,arg,options?.getPendingMeta?.({requestId,arg},{getState,extra}))),finalAction=await Promise.race([abortedPromise,Promise.resolve(payloadCreator(arg,{dispatch,getState,extra,requestId,signal:abortController.signal,abort,rejectWithValue:(value,meta)=>new RejectWithValue(value,meta),fulfillWithValue:(value,meta)=>new FulfillWithMeta(value,meta)})).then((result=>{if(result instanceof RejectWithValue)throw result;return result instanceof FulfillWithMeta?fulfilled(result.payload,requestId,arg,result.meta):fulfilled(result,requestId,arg)}))])}catch(err){finalAction=err instanceof RejectWithValue?rejected(null,requestId,arg,err.payload,err.meta):rejected(err,requestId,arg)}finally{abortHandler&&abortController.signal.removeEventListener("abort",abortHandler)}return options&&!options.dispatchConditionRejection&&rejected.match(finalAction)&&finalAction.meta.condition||dispatch(finalAction),finalAction}();return Object.assign(promise,{abort,requestId,arg,unwrap:()=>promise.then(unwrapResult)})}}),{pending,rejected,fulfilled,settled:isAnyOf(rejected,fulfilled),typePrefix})}return createAsyncThunk2.withTypes=()=>createAsyncThunk2,createAsyncThunk2})();function unwrapResult(action){if(action.meta&&action.meta.rejectedWithValue)throw action.payload;if(action.error)throw action.error;return action.payload}var asyncThunkSymbol=Symbol.for("rtk-slice-createasyncthunk");function getType(slice,actionKey){return`${slice}/${actionKey}`}function buildCreateSlice({creators}={}){const cAT=creators?.asyncThunk?.[asyncThunkSymbol];return function createSlice2(options){const{name,reducerPath=name}=options;if(!name)throw new Error(formatProdErrorMessage(11));const reducers=("function"==typeof options.reducers?options.reducers(function buildReducerCreators(){function asyncThunk(payloadCreator,config){return{_reducerDefinitionType:"asyncThunk",payloadCreator,...config}}return asyncThunk.withTypes=()=>asyncThunk,{reducer:caseReducer=>Object.assign({[caseReducer.name]:(...args)=>caseReducer(...args)}[caseReducer.name],{_reducerDefinitionType:"reducer"}),preparedReducer:(prepare,reducer)=>({_reducerDefinitionType:"reducerWithPrepare",prepare,reducer}),asyncThunk}}()):options.reducers)||{},reducerNames=Object.keys(reducers),context={sliceCaseReducersByName:{},sliceCaseReducersByType:{},actionCreators:{},sliceMatchers:[]},contextMethods={addCase(typeOrActionCreator,reducer2){const type="string"==typeof typeOrActionCreator?typeOrActionCreator:typeOrActionCreator.type;if(!type)throw new Error(formatProdErrorMessage(12));if(type in context.sliceCaseReducersByType)throw new Error(formatProdErrorMessage(13));return context.sliceCaseReducersByType[type]=reducer2,contextMethods},addMatcher:(matcher,reducer2)=>(context.sliceMatchers.push({matcher,reducer:reducer2}),contextMethods),exposeAction:(name2,actionCreator)=>(context.actionCreators[name2]=actionCreator,contextMethods),exposeCaseReducer:(name2,reducer2)=>(context.sliceCaseReducersByName[name2]=reducer2,contextMethods)};function buildReducer(){const[extraReducers={},actionMatchers=[],defaultCaseReducer]="function"==typeof options.extraReducers?executeReducerBuilderCallback(options.extraReducers):[options.extraReducers],finalCaseReducers={...extraReducers,...context.sliceCaseReducersByType};return function createReducer(initialState,mapOrBuilderCallback){let getInitialState,[actionsMap,finalActionMatchers,finalDefaultCaseReducer]=executeReducerBuilderCallback(mapOrBuilderCallback);if(function isStateFunction(x){return"function"==typeof x}(initialState))getInitialState=()=>freezeDraftable(initialState());else{const frozenInitialState=freezeDraftable(initialState);getInitialState=()=>frozenInitialState}function reducer(state=getInitialState(),action){let caseReducers=[actionsMap[action.type],...finalActionMatchers.filter((({matcher})=>matcher(action))).map((({reducer:reducer2})=>reducer2))];return 0===caseReducers.filter((cr=>!!cr)).length&&(caseReducers=[finalDefaultCaseReducer]),caseReducers.reduce(((previousState,caseReducer)=>{if(caseReducer){if((0,immer.Qx)(previousState)){const result=caseReducer(previousState,action);return void 0===result?previousState:result}if((0,immer.a6)(previousState))return(0,immer.jM)(previousState,(draft=>caseReducer(draft,action)));{const result=caseReducer(previousState,action);if(void 0===result){if(null===previousState)return previousState;throw Error("A case reducer on a non-draftable value must not return undefined")}return result}}return previousState}),state)}return reducer.getInitialState=getInitialState,reducer}(options.initialState,(builder=>{for(let key in finalCaseReducers)builder.addCase(key,finalCaseReducers[key]);for(let sM of context.sliceMatchers)builder.addMatcher(sM.matcher,sM.reducer);for(let m of actionMatchers)builder.addMatcher(m.matcher,m.reducer);defaultCaseReducer&&builder.addDefaultCase(defaultCaseReducer)}))}reducerNames.forEach((reducerName=>{const reducerDefinition=reducers[reducerName],reducerDetails={reducerName,type:getType(name,reducerName),createNotation:"function"==typeof options.reducers};!function isAsyncThunkSliceReducerDefinition(reducerDefinition){return"asyncThunk"===reducerDefinition._reducerDefinitionType}(reducerDefinition)?function handleNormalReducerDefinition({type,reducerName,createNotation},maybeReducerWithPrepare,context){let caseReducer,prepareCallback;if("reducer"in maybeReducerWithPrepare){if(createNotation&&!function isCaseReducerWithPrepareDefinition(reducerDefinition){return"reducerWithPrepare"===reducerDefinition._reducerDefinitionType}(maybeReducerWithPrepare))throw new Error(formatProdErrorMessage(17));caseReducer=maybeReducerWithPrepare.reducer,prepareCallback=maybeReducerWithPrepare.prepare}else caseReducer=maybeReducerWithPrepare;context.addCase(type,caseReducer).exposeCaseReducer(reducerName,caseReducer).exposeAction(reducerName,prepareCallback?createAction(type,prepareCallback):createAction(type))}(reducerDetails,reducerDefinition,contextMethods):function handleThunkCaseReducerDefinition({type,reducerName},reducerDefinition,context,cAT){if(!cAT)throw new Error(formatProdErrorMessage(18));const{payloadCreator,fulfilled,pending,rejected,settled,options}=reducerDefinition,thunk=cAT(type,payloadCreator,options);context.exposeAction(reducerName,thunk),fulfilled&&context.addCase(thunk.fulfilled,fulfilled);pending&&context.addCase(thunk.pending,pending);rejected&&context.addCase(thunk.rejected,rejected);settled&&context.addMatcher(thunk.settled,settled);context.exposeCaseReducer(reducerName,{fulfilled:fulfilled||noop,pending:pending||noop,rejected:rejected||noop,settled:settled||noop})}(reducerDetails,reducerDefinition,contextMethods,cAT)}));const selectSelf=state=>state,injectedSelectorCache=new Map;let _reducer;function reducer(state,action){return _reducer||(_reducer=buildReducer()),_reducer(state,action)}function getInitialState(){return _reducer||(_reducer=buildReducer()),_reducer.getInitialState()}function makeSelectorProps(reducerPath2,injected=!1){function selectSlice(state){let sliceState=state[reducerPath2];return void 0===sliceState&&injected&&(sliceState=getInitialState()),sliceState}function getSelectors(selectState=selectSelf){const selectorCache=getOrInsertComputed(injectedSelectorCache,injected,(()=>new WeakMap));return getOrInsertComputed(selectorCache,selectState,(()=>{const map={};for(const[name2,selector]of Object.entries(options.selectors??{}))map[name2]=wrapSelector(selector,selectState,getInitialState,injected);return map}))}return{reducerPath:reducerPath2,getSelectors,get selectors(){return getSelectors(selectSlice)},selectSlice}}const slice={name,reducer,actions:context.actionCreators,caseReducers:context.sliceCaseReducersByName,getInitialState,...makeSelectorProps(reducerPath),injectInto(injectable,{reducerPath:pathOpt,...config}={}){const newReducerPath=pathOpt??reducerPath;return injectable.inject({reducerPath:newReducerPath,reducer},config),{...slice,...makeSelectorProps(newReducerPath,!0)}}};return slice}}function wrapSelector(selector,selectState,getInitialState,injected){function wrapper(rootState,...args){let sliceState=selectState(rootState);return void 0===sliceState&&injected&&(sliceState=getInitialState()),selector(sliceState,...args)}return wrapper.unwrapped=selector,wrapper}var createSlice=buildCreateSlice();function noop(){}var TaskAbortError=class{constructor(code){this.code=code,this.message=`task cancelled (reason: ${code})`}name="TaskAbortError";message},assertFunction=(func,expected)=>{if("function"!=typeof func)throw new TypeError(formatProdErrorMessage(32))},noop2=()=>{},catchRejection=(promise,onError=noop2)=>(promise.catch(onError),promise),addAbortSignalListener=(abortSignal,callback)=>(abortSignal.addEventListener("abort",callback,{once:!0}),()=>abortSignal.removeEventListener("abort",callback)),abortControllerWithReason=(abortController,reason)=>{const signal=abortController.signal;signal.aborted||("reason"in signal||Object.defineProperty(signal,"reason",{enumerable:!0,value:reason,configurable:!0,writable:!0}),abortController.abort(reason))},validateActive=signal=>{if(signal.aborted){const{reason}=signal;throw new TaskAbortError(reason)}};function raceWithSignal(signal,promise){let cleanup=noop2;return new Promise(((resolve,reject)=>{const notifyRejection=()=>reject(new TaskAbortError(signal.reason));signal.aborted?notifyRejection():(cleanup=addAbortSignalListener(signal,notifyRejection),promise.finally((()=>cleanup())).then(resolve,reject))})).finally((()=>{cleanup=noop2}))}var createPause=signal=>promise=>catchRejection(raceWithSignal(signal,promise).then((output=>(validateActive(signal),output)))),createDelay=signal=>{const pause=createPause(signal);return timeoutMs=>pause(new Promise((resolve=>setTimeout(resolve,timeoutMs))))},{assign:redux_toolkit_modern_assign}=Object,INTERNAL_NIL_TOKEN={},alm="listenerMiddleware",createFork=(parentAbortSignal,parentBlockingPromises)=>(taskExecutor,opts)=>{assertFunction(taskExecutor);const childAbortController=new AbortController;var controller;controller=childAbortController,addAbortSignalListener(parentAbortSignal,(()=>abortControllerWithReason(controller,parentAbortSignal.reason)));const result=(async(task2,cleanUp)=>{try{return await Promise.resolve(),{status:"ok",value:await task2()}}catch(error){return{status:error instanceof TaskAbortError?"cancelled":"rejected",error}}finally{cleanUp?.()}})((async()=>{validateActive(parentAbortSignal),validateActive(childAbortController.signal);const result2=await taskExecutor({pause:createPause(childAbortController.signal),delay:createDelay(childAbortController.signal),signal:childAbortController.signal});return validateActive(childAbortController.signal),result2}),(()=>abortControllerWithReason(childAbortController,"task-completed")));return opts?.autoJoin&&parentBlockingPromises.push(result.catch(noop2)),{result:createPause(parentAbortSignal)(result),cancel(){abortControllerWithReason(childAbortController,"task-cancelled")}}},createTakePattern=(startListening,signal)=>(predicate,timeout)=>catchRejection((async(predicate,timeout)=>{validateActive(signal);let unsubscribe=()=>{};const promises=[new Promise(((resolve,reject)=>{let stopListening=startListening({predicate,effect:(action,listenerApi)=>{listenerApi.unsubscribe(),resolve([action,listenerApi.getState(),listenerApi.getOriginalState()])}});unsubscribe=()=>{stopListening(),reject()}}))];null!=timeout&&promises.push(new Promise((resolve=>setTimeout(resolve,timeout,null))));try{const output=await raceWithSignal(signal,Promise.race(promises));return validateActive(signal),output}finally{unsubscribe()}})(predicate,timeout)),getListenerEntryPropsFrom=options=>{let{type,actionCreator,matcher,predicate,effect}=options;if(type)predicate=createAction(type).match;else if(actionCreator)type=actionCreator.type,predicate=actionCreator.match;else if(matcher)predicate=matcher;else if(!predicate)throw new Error(formatProdErrorMessage(21));return assertFunction(effect),{predicate,type,effect}},createListenerEntry=redux_toolkit_modern_assign((options=>{const{type,predicate,effect}=getListenerEntryPropsFrom(options);return{id:nanoid(),effect,type,predicate,pending:new Set,unsubscribe:()=>{throw new Error(formatProdErrorMessage(22))}}}),{withTypes:()=>createListenerEntry}),findListenerEntry=(listenerMap,options)=>{const{type,effect,predicate}=getListenerEntryPropsFrom(options);return Array.from(listenerMap.values()).find((entry=>("string"==typeof type?entry.type===type:entry.predicate===predicate)&&entry.effect===effect))},cancelActiveListeners=entry=>{entry.pending.forEach((controller=>{abortControllerWithReason(controller,"listener-cancelled")}))},safelyNotifyError=(errorHandler,errorToNotify,errorInfo)=>{try{errorHandler(errorToNotify,errorInfo)}catch(errorHandlerError){setTimeout((()=>{throw errorHandlerError}),0)}},addListener=redux_toolkit_modern_assign(createAction(`${alm}/add`),{withTypes:()=>addListener}),clearAllListeners=createAction(`${alm}/removeAll`),removeListener=redux_toolkit_modern_assign(createAction(`${alm}/remove`),{withTypes:()=>removeListener}),defaultErrorHandler=(...args)=>{console.error(`${alm}/error`,...args)},createListenerMiddleware=(middlewareOptions={})=>{const listenerMap=new Map,{extra,onError=defaultErrorHandler}=middlewareOptions;assertFunction(onError);const startListening=options=>(entry=>(entry.unsubscribe=()=>listenerMap.delete(entry.id),listenerMap.set(entry.id,entry),cancelOptions=>{entry.unsubscribe(),cancelOptions?.cancelActive&&cancelActiveListeners(entry)}))(findListenerEntry(listenerMap,options)??createListenerEntry(options));redux_toolkit_modern_assign(startListening,{withTypes:()=>startListening});const stopListening=options=>{const entry=findListenerEntry(listenerMap,options);return entry&&(entry.unsubscribe(),options.cancelActive&&cancelActiveListeners(entry)),!!entry};redux_toolkit_modern_assign(stopListening,{withTypes:()=>stopListening});const notifyListener=async(entry,action,api,getOriginalState)=>{const internalTaskController=new AbortController,take=createTakePattern(startListening,internalTaskController.signal),autoJoinPromises=[];try{entry.pending.add(internalTaskController),await Promise.resolve(entry.effect(action,redux_toolkit_modern_assign({},api,{getOriginalState,condition:(predicate,timeout)=>take(predicate,timeout).then(Boolean),take,delay:createDelay(internalTaskController.signal),pause:createPause(internalTaskController.signal),extra,signal:internalTaskController.signal,fork:createFork(internalTaskController.signal,autoJoinPromises),unsubscribe:entry.unsubscribe,subscribe:()=>{listenerMap.set(entry.id,entry)},cancelActiveListeners:()=>{entry.pending.forEach(((controller,_,set)=>{controller!==internalTaskController&&(abortControllerWithReason(controller,"listener-cancelled"),set.delete(controller))}))},cancel:()=>{abortControllerWithReason(internalTaskController,"listener-cancelled"),entry.pending.delete(internalTaskController)},throwIfCancelled:()=>{validateActive(internalTaskController.signal)}})))}catch(listenerError){listenerError instanceof TaskAbortError||safelyNotifyError(onError,listenerError,{raisedBy:"effect"})}finally{await Promise.all(autoJoinPromises),abortControllerWithReason(internalTaskController,"listener-completed"),entry.pending.delete(internalTaskController)}},clearListenerMiddleware=(listenerMap=>()=>{listenerMap.forEach(cancelActiveListeners),listenerMap.clear()})(listenerMap);return{middleware:api=>next=>action=>{if(!(0,redux.ve)(action))return next(action);if(addListener.match(action))return startListening(action.payload);if(clearAllListeners.match(action))return void clearListenerMiddleware();if(removeListener.match(action))return stopListening(action.payload);let originalState=api.getState();const getOriginalState=()=>{if(originalState===INTERNAL_NIL_TOKEN)throw new Error(formatProdErrorMessage(23));return originalState};let result;try{if(result=next(action),listenerMap.size>0){const currentState=api.getState(),listenerEntries=Array.from(listenerMap.values());for(const entry of listenerEntries){let runListener=!1;try{runListener=entry.predicate(action,currentState,originalState)}catch(predicateError){runListener=!1,safelyNotifyError(onError,predicateError,{raisedBy:"predicate"})}runListener&&notifyListener(entry,action,api,getOriginalState)}}}finally{originalState=INTERNAL_NIL_TOKEN}return result},startListening,stopListening,clearListeners:clearListenerMiddleware}};Symbol.for("rtk-state-proxy-original");function formatProdErrorMessage(code){return`Minified Redux Toolkit error #${code}; visit https://redux-toolkit.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `}},"./node_modules/core-js/internals/classof.js":(module,__unused_webpack_exports,__webpack_require__)=>{var TO_STRING_TAG_SUPPORT=__webpack_require__("./node_modules/core-js/internals/to-string-tag-support.js"),isCallable=__webpack_require__("./node_modules/core-js/internals/is-callable.js"),classofRaw=__webpack_require__("./node_modules/core-js/internals/classof-raw.js"),TO_STRING_TAG=__webpack_require__("./node_modules/core-js/internals/well-known-symbol.js")("toStringTag"),$Object=Object,CORRECT_ARGUMENTS="Arguments"===classofRaw(function(){return arguments}());module.exports=TO_STRING_TAG_SUPPORT?classofRaw:function(it){var O,tag,result;return void 0===it?"Undefined":null===it?"Null":"string"==typeof(tag=function(it,key){try{return it[key]}catch(error){}}(O=$Object(it),TO_STRING_TAG))?tag:CORRECT_ARGUMENTS?classofRaw(O):"Object"===(result=classofRaw(O))&&isCallable(O.callee)?"Arguments":result}},"./node_modules/core-js/internals/function-bind-context.js":(module,__unused_webpack_exports,__webpack_require__)=>{var uncurryThis=__webpack_require__("./node_modules/core-js/internals/function-uncurry-this-clause.js"),aCallable=__webpack_require__("./node_modules/core-js/internals/a-callable.js"),NATIVE_BIND=__webpack_require__("./node_modules/core-js/internals/function-bind-native.js"),bind=uncurryThis(uncurryThis.bind);module.exports=function(fn,that){return aCallable(fn),void 0===that?fn:NATIVE_BIND?bind(fn,that):function(){return fn.apply(that,arguments)}}},"./node_modules/core-js/internals/function-uncurry-this-clause.js":(module,__unused_webpack_exports,__webpack_require__)=>{var classofRaw=__webpack_require__("./node_modules/core-js/internals/classof-raw.js"),uncurryThis=__webpack_require__("./node_modules/core-js/internals/function-uncurry-this.js");module.exports=function(fn){if("Function"===classofRaw(fn))return uncurryThis(fn)}},"./node_modules/core-js/internals/get-iterator-method.js":(module,__unused_webpack_exports,__webpack_require__)=>{var classof=__webpack_require__("./node_modules/core-js/internals/classof.js"),getMethod=__webpack_require__("./node_modules/core-js/internals/get-method.js"),isNullOrUndefined=__webpack_require__("./node_modules/core-js/internals/is-null-or-undefined.js"),Iterators=__webpack_require__("./node_modules/core-js/internals/iterators.js"),ITERATOR=__webpack_require__("./node_modules/core-js/internals/well-known-symbol.js")("iterator");module.exports=function(it){if(!isNullOrUndefined(it))return getMethod(it,ITERATOR)||getMethod(it,"@@iterator")||Iterators[classof(it)]}},"./node_modules/core-js/internals/get-iterator.js":(module,__unused_webpack_exports,__webpack_require__)=>{var call=__webpack_require__("./node_modules/core-js/internals/function-call.js"),aCallable=__webpack_require__("./node_modules/core-js/internals/a-callable.js"),anObject=__webpack_require__("./node_modules/core-js/internals/an-object.js"),tryToString=__webpack_require__("./node_modules/core-js/internals/try-to-string.js"),getIteratorMethod=__webpack_require__("./node_modules/core-js/internals/get-iterator-method.js"),$TypeError=TypeError;module.exports=function(argument,usingIterator){var iteratorMethod=arguments.length<2?getIteratorMethod(argument):usingIterator;if(aCallable(iteratorMethod))return anObject(call(iteratorMethod,argument));throw new $TypeError(tryToString(argument)+" is not iterable")}},"./node_modules/core-js/internals/is-array-iterator-method.js":(module,__unused_webpack_exports,__webpack_require__)=>{var wellKnownSymbol=__webpack_require__("./node_modules/core-js/internals/well-known-symbol.js"),Iterators=__webpack_require__("./node_modules/core-js/internals/iterators.js"),ITERATOR=wellKnownSymbol("iterator"),ArrayPrototype=Array.prototype;module.exports=function(it){return void 0!==it&&(Iterators.Array===it||ArrayPrototype[ITERATOR]===it)}},"./node_modules/core-js/internals/iterate.js":(module,__unused_webpack_exports,__webpack_require__)=>{var bind=__webpack_require__("./node_modules/core-js/internals/function-bind-context.js"),call=__webpack_require__("./node_modules/core-js/internals/function-call.js"),anObject=__webpack_require__("./node_modules/core-js/internals/an-object.js"),tryToString=__webpack_require__("./node_modules/core-js/internals/try-to-string.js"),isArrayIteratorMethod=__webpack_require__("./node_modules/core-js/internals/is-array-iterator-method.js"),lengthOfArrayLike=__webpack_require__("./node_modules/core-js/internals/length-of-array-like.js"),isPrototypeOf=__webpack_require__("./node_modules/core-js/internals/object-is-prototype-of.js"),getIterator=__webpack_require__("./node_modules/core-js/internals/get-iterator.js"),getIteratorMethod=__webpack_require__("./node_modules/core-js/internals/get-iterator-method.js"),iteratorClose=__webpack_require__("./node_modules/core-js/internals/iterator-close.js"),$TypeError=TypeError,Result=function(stopped,result){this.stopped=stopped,this.result=result},ResultPrototype=Result.prototype;module.exports=function(iterable,unboundFunction,options){var iterator,iterFn,index,length,result,next,step,that=options&&options.that,AS_ENTRIES=!(!options||!options.AS_ENTRIES),IS_RECORD=!(!options||!options.IS_RECORD),IS_ITERATOR=!(!options||!options.IS_ITERATOR),INTERRUPTED=!(!options||!options.INTERRUPTED),fn=bind(unboundFunction,that),stop=function(condition){return iterator&&iteratorClose(iterator,"normal",condition),new Result(!0,condition)},callFn=function(value){return AS_ENTRIES?(anObject(value),INTERRUPTED?fn(value[0],value[1],stop):fn(value[0],value[1])):INTERRUPTED?fn(value,stop):fn(value)};if(IS_RECORD)iterator=iterable.iterator;else if(IS_ITERATOR)iterator=iterable;else{if(!(iterFn=getIteratorMethod(iterable)))throw new $TypeError(tryToString(iterable)+" is not iterable");if(isArrayIteratorMethod(iterFn)){for(index=0,length=lengthOfArrayLike(iterable);length>index;index++)if((result=callFn(iterable[index]))&&isPrototypeOf(ResultPrototype,result))return result;return new Result(!1)}iterator=getIterator(iterable,iterFn)}for(next=IS_RECORD?iterable.next:iterator.next;!(step=call(next,iterator)).done;){try{result=callFn(step.value)}catch(error){iteratorClose(iterator,"throw",error)}if("object"==typeof result&&result&&isPrototypeOf(ResultPrototype,result))return result}return new Result(!1)}},"./node_modules/core-js/internals/iterators.js":module=>{module.exports={}},"./node_modules/core-js/internals/to-string-tag-support.js":(module,__unused_webpack_exports,__webpack_require__)=>{var test={};test[__webpack_require__("./node_modules/core-js/internals/well-known-symbol.js")("toStringTag")]="z",module.exports="[object z]"===String(test)},"./node_modules/core-js/modules/es.iterator.find.js":(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{var $=__webpack_require__("./node_modules/core-js/internals/export.js"),iterate=__webpack_require__("./node_modules/core-js/internals/iterate.js"),aCallable=__webpack_require__("./node_modules/core-js/internals/a-callable.js"),anObject=__webpack_require__("./node_modules/core-js/internals/an-object.js"),getIteratorDirect=__webpack_require__("./node_modules/core-js/internals/get-iterator-direct.js");$({target:"Iterator",proto:!0,real:!0},{find:function find(predicate){anObject(this),aCallable(predicate);var record=getIteratorDirect(this),counter=0;return iterate(record,(function(value,stop){if(predicate(value,counter++))return stop(value)}),{IS_RECORD:!0,INTERRUPTED:!0}).result}})},"./node_modules/immer/dist/immer.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{$i:()=>applyPatches,Qx:()=>isDraft,YT:()=>enablePatches,a6:()=>isDraftable,c2:()=>original,jM:()=>produce,vI:()=>produceWithPatches});var NOTHING=Symbol.for("immer-nothing"),DRAFTABLE=Symbol.for("immer-draftable"),DRAFT_STATE=Symbol.for("immer-state");function die(error,...args){throw new Error(`[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`)}var getPrototypeOf=Object.getPrototypeOf;function isDraft(value){return!!value&&!!value[DRAFT_STATE]}function isDraftable(value){return!!value&&(isPlainObject(value)||Array.isArray(value)||!!value[DRAFTABLE]||!!value.constructor?.[DRAFTABLE]||isMap(value)||isSet(value))}var objectCtorString=Object.prototype.constructor.toString();function isPlainObject(value){if(!value||"object"!=typeof value)return!1;const proto=getPrototypeOf(value);if(null===proto)return!0;const Ctor=Object.hasOwnProperty.call(proto,"constructor")&&proto.constructor;return Ctor===Object||"function"==typeof Ctor&&Function.toString.call(Ctor)===objectCtorString}function original(value){return isDraft(value)||die(15),value[DRAFT_STATE].base_}function each(obj,iter){0===getArchtype(obj)?Reflect.ownKeys(obj).forEach((key=>{iter(key,obj[key],obj)})):obj.forEach(((entry,index)=>iter(index,entry,obj)))}function getArchtype(thing){const state=thing[DRAFT_STATE];return state?state.type_:Array.isArray(thing)?1:isMap(thing)?2:isSet(thing)?3:0}function has(thing,prop){return 2===getArchtype(thing)?thing.has(prop):Object.prototype.hasOwnProperty.call(thing,prop)}function get(thing,prop){return 2===getArchtype(thing)?thing.get(prop):thing[prop]}function set(thing,propOrOldValue,value){const t=getArchtype(thing);2===t?thing.set(propOrOldValue,value):3===t?thing.add(value):thing[propOrOldValue]=value}function isMap(target){return target instanceof Map}function isSet(target){return target instanceof Set}function latest(state){return state.copy_||state.base_}function shallowCopy(base,strict){if(isMap(base))return new Map(base);if(isSet(base))return new Set(base);if(Array.isArray(base))return Array.prototype.slice.call(base);const isPlain=isPlainObject(base);if(!0===strict||"class_only"===strict&&!isPlain){const descriptors=Object.getOwnPropertyDescriptors(base);delete descriptors[DRAFT_STATE];let keys=Reflect.ownKeys(descriptors);for(let i=0;i<keys.length;i++){const key=keys[i],desc=descriptors[key];!1===desc.writable&&(desc.writable=!0,desc.configurable=!0),(desc.get||desc.set)&&(descriptors[key]={configurable:!0,writable:!0,enumerable:desc.enumerable,value:base[key]})}return Object.create(getPrototypeOf(base),descriptors)}{const proto=getPrototypeOf(base);if(null!==proto&&isPlain)return{...base};const obj=Object.create(proto);return Object.assign(obj,base)}}function freeze(obj,deep=!1){return isFrozen(obj)||isDraft(obj)||!isDraftable(obj)||(getArchtype(obj)>1&&(obj.set=obj.add=obj.clear=obj.delete=dontMutateFrozenCollections),Object.freeze(obj),deep&&Object.entries(obj).forEach((([key,value])=>freeze(value,!0)))),obj}function dontMutateFrozenCollections(){die(2)}function isFrozen(obj){return Object.isFrozen(obj)}var currentScope,plugins={};function getPlugin(pluginKey){const plugin=plugins[pluginKey];return plugin||die(0),plugin}function loadPlugin(pluginKey,implementation){plugins[pluginKey]||(plugins[pluginKey]=implementation)}function getCurrentScope(){return currentScope}function usePatchesInScope(scope,patchListener){patchListener&&(getPlugin("Patches"),scope.patches_=[],scope.inversePatches_=[],scope.patchListener_=patchListener)}function revokeScope(scope){leaveScope(scope),scope.drafts_.forEach(revokeDraft),scope.drafts_=null}function leaveScope(scope){scope===currentScope&&(currentScope=scope.parent_)}function enterScope(immer2){return currentScope=function createScope(parent_,immer_){return{drafts_:[],parent_,immer_,canAutoFreeze_:!0,unfinalizedDrafts_:0}}(currentScope,immer2)}function revokeDraft(draft){const state=draft[DRAFT_STATE];0===state.type_||1===state.type_?state.revoke_():state.revoked_=!0}function processResult(result,scope){scope.unfinalizedDrafts_=scope.drafts_.length;const baseDraft=scope.drafts_[0];return void 0!==result&&result!==baseDraft?(baseDraft[DRAFT_STATE].modified_&&(revokeScope(scope),die(4)),isDraftable(result)&&(result=finalize(scope,result),scope.parent_||maybeFreeze(scope,result)),scope.patches_&&getPlugin("Patches").generateReplacementPatches_(baseDraft[DRAFT_STATE].base_,result,scope.patches_,scope.inversePatches_)):result=finalize(scope,baseDraft,[]),revokeScope(scope),scope.patches_&&scope.patchListener_(scope.patches_,scope.inversePatches_),result!==NOTHING?result:void 0}function finalize(rootScope,value,path){if(isFrozen(value))return value;const state=value[DRAFT_STATE];if(!state)return each(value,((key,childValue)=>finalizeProperty(rootScope,state,value,key,childValue,path))),value;if(state.scope_!==rootScope)return value;if(!state.modified_)return maybeFreeze(rootScope,state.base_,!0),state.base_;if(!state.finalized_){state.finalized_=!0,state.scope_.unfinalizedDrafts_--;const result=state.copy_;let resultEach=result,isSet2=!1;3===state.type_&&(resultEach=new Set(result),result.clear(),isSet2=!0),each(resultEach,((key,childValue)=>finalizeProperty(rootScope,state,result,key,childValue,path,isSet2))),maybeFreeze(rootScope,result,!1),path&&rootScope.patches_&&getPlugin("Patches").generatePatches_(state,path,rootScope.patches_,rootScope.inversePatches_)}return state.copy_}function finalizeProperty(rootScope,parentState,targetObject,prop,childValue,rootPath,targetIsSet){if(isDraft(childValue)){const res=finalize(rootScope,childValue,rootPath&&parentState&&3!==parentState.type_&&!has(parentState.assigned_,prop)?rootPath.concat(prop):void 0);if(set(targetObject,prop,res),!isDraft(res))return;rootScope.canAutoFreeze_=!1}else targetIsSet&&targetObject.add(childValue);if(isDraftable(childValue)&&!isFrozen(childValue)){if(!rootScope.immer_.autoFreeze_&&rootScope.unfinalizedDrafts_<1)return;finalize(rootScope,childValue),parentState&&parentState.scope_.parent_||"symbol"==typeof prop||!Object.prototype.propertyIsEnumerable.call(targetObject,prop)||maybeFreeze(rootScope,childValue)}}function maybeFreeze(scope,value,deep=!1){!scope.parent_&&scope.immer_.autoFreeze_&&scope.canAutoFreeze_&&freeze(value,deep)}var objectTraps={get(state,prop){if(prop===DRAFT_STATE)return state;const source=latest(state);if(!has(source,prop))return function readPropFromProto(state,source,prop){const desc=getDescriptorFromProto(source,prop);return desc?"value"in desc?desc.value:desc.get?.call(state.draft_):void 0}(state,source,prop);const value=source[prop];return state.finalized_||!isDraftable(value)?value:value===peek(state.base_,prop)?(prepareCopy(state),state.copy_[prop]=createProxy(value,state)):value},has:(state,prop)=>prop in latest(state),ownKeys:state=>Reflect.ownKeys(latest(state)),set(state,prop,value){const desc=getDescriptorFromProto(latest(state),prop);if(desc?.set)return desc.set.call(state.draft_,value),!0;if(!state.modified_){const current2=peek(latest(state),prop),currentState=current2?.[DRAFT_STATE];if(currentState&&currentState.base_===value)return state.copy_[prop]=value,state.assigned_[prop]=!1,!0;if(function is(x,y){return x===y?0!==x||1/x==1/y:x!=x&&y!=y}(value,current2)&&(void 0!==value||has(state.base_,prop)))return!0;prepareCopy(state),markChanged(state)}return state.copy_[prop]===value&&(void 0!==value||prop in state.copy_)||Number.isNaN(value)&&Number.isNaN(state.copy_[prop])||(state.copy_[prop]=value,state.assigned_[prop]=!0),!0},deleteProperty:(state,prop)=>(void 0!==peek(state.base_,prop)||prop in state.base_?(state.assigned_[prop]=!1,prepareCopy(state),markChanged(state)):delete state.assigned_[prop],state.copy_&&delete state.copy_[prop],!0),getOwnPropertyDescriptor(state,prop){const owner=latest(state),desc=Reflect.getOwnPropertyDescriptor(owner,prop);return desc?{writable:!0,configurable:1!==state.type_||"length"!==prop,enumerable:desc.enumerable,value:owner[prop]}:desc},defineProperty(){die(11)},getPrototypeOf:state=>getPrototypeOf(state.base_),setPrototypeOf(){die(12)}},arrayTraps={};function peek(draft,prop){const state=draft[DRAFT_STATE];return(state?latest(state):draft)[prop]}function getDescriptorFromProto(source,prop){if(!(prop in source))return;let proto=getPrototypeOf(source);for(;proto;){const desc=Object.getOwnPropertyDescriptor(proto,prop);if(desc)return desc;proto=getPrototypeOf(proto)}}function markChanged(state){state.modified_||(state.modified_=!0,state.parent_&&markChanged(state.parent_))}function prepareCopy(state){state.copy_||(state.copy_=shallowCopy(state.base_,state.scope_.immer_.useStrictShallowCopy_))}each(objectTraps,((key,fn)=>{arrayTraps[key]=function(){return arguments[0]=arguments[0][0],fn.apply(this,arguments)}})),arrayTraps.deleteProperty=function(state,prop){return arrayTraps.set.call(this,state,prop,void 0)},arrayTraps.set=function(state,prop,value){return objectTraps.set.call(this,state[0],prop,value,state[0])};function createProxy(value,parent){const draft=isMap(value)?getPlugin("MapSet").proxyMap_(value,parent):isSet(value)?getPlugin("MapSet").proxySet_(value,parent):function createProxyProxy(base,parent){const isArray=Array.isArray(base),state={type_:isArray?1:0,scope_:parent?parent.scope_:getCurrentScope(),modified_:!1,finalized_:!1,assigned_:{},parent_:parent,base_:base,draft_:null,copy_:null,revoke_:null,isManual_:!1};let target=state,traps=objectTraps;isArray&&(target=[state],traps=arrayTraps);const{revoke,proxy}=Proxy.revocable(target,traps);return state.draft_=proxy,state.revoke_=revoke,proxy}(value,parent);return(parent?parent.scope_:getCurrentScope()).drafts_.push(draft),draft}function currentImpl(value){if(!isDraftable(value)||isFrozen(value))return value;const state=value[DRAFT_STATE];let copy;if(state){if(!state.modified_)return state.base_;state.finalized_=!0,copy=shallowCopy(value,state.scope_.immer_.useStrictShallowCopy_)}else copy=shallowCopy(value,!0);return each(copy,((key,childValue)=>{set(copy,key,currentImpl(childValue))})),state&&(state.finalized_=!1),copy}function enablePatches(){const REPLACE="replace",ADD="add",REMOVE="remove";function deepClonePatchValue(obj){if(!isDraftable(obj))return obj;if(Array.isArray(obj))return obj.map(deepClonePatchValue);if(isMap(obj))return new Map(Array.from(obj.entries()).map((([k,v])=>[k,deepClonePatchValue(v)])));if(isSet(obj))return new Set(Array.from(obj).map(deepClonePatchValue));const cloned=Object.create(getPrototypeOf(obj));for(const key in obj)cloned[key]=deepClonePatchValue(obj[key]);return has(obj,DRAFTABLE)&&(cloned[DRAFTABLE]=obj[DRAFTABLE]),cloned}function clonePatchValueIfNeeded(obj){return isDraft(obj)?deepClonePatchValue(obj):obj}loadPlugin("Patches",{applyPatches_:function applyPatches_(draft,patches){return patches.forEach((patch=>{const{path,op}=patch;let base=draft;for(let i=0;i<path.length-1;i++){const parentType=getArchtype(base);let p=path[i];"string"!=typeof p&&"number"!=typeof p&&(p=""+p),0!==parentType&&1!==parentType||"__proto__"!==p&&"constructor"!==p||die(19),"function"==typeof base&&"prototype"===p&&die(19),base=get(base,p),"object"!=typeof base&&die(18,path.join("/"))}const type=getArchtype(base),value=deepClonePatchValue(patch.value),key=path[path.length-1];switch(op){case REPLACE:switch(type){case 2:return base.set(key,value);case 3:die(16);default:return base[key]=value}case ADD:switch(type){case 1:return"-"===key?base.push(value):base.splice(key,0,value);case 2:return base.set(key,value);case 3:return base.add(value);default:return base[key]=value}case REMOVE:switch(type){case 1:return base.splice(key,1);case 2:return base.delete(key);case 3:return base.delete(patch.value);default:return delete base[key]}default:die(17)}})),draft},generatePatches_:function generatePatches_(state,basePath,patches,inversePatches){switch(state.type_){case 0:case 2:return function generatePatchesFromAssigned(state,basePath,patches,inversePatches){const{base_,copy_}=state;each(state.assigned_,((key,assignedValue)=>{const origValue=get(base_,key),value=get(copy_,key),op=assignedValue?has(base_,key)?REPLACE:ADD:REMOVE;if(origValue===value&&op===REPLACE)return;const path=basePath.concat(key);patches.push(op===REMOVE?{op,path}:{op,path,value}),inversePatches.push(op===ADD?{op:REMOVE,path}:op===REMOVE?{op:ADD,path,value:clonePatchValueIfNeeded(origValue)}:{op:REPLACE,path,value:clonePatchValueIfNeeded(origValue)})}))}(state,basePath,patches,inversePatches);case 1:return function generateArrayPatches(state,basePath,patches,inversePatches){let{base_,assigned_}=state,copy_=state.copy_;copy_.length<base_.length&&([base_,copy_]=[copy_,base_],[patches,inversePatches]=[inversePatches,patches]);for(let i=0;i<base_.length;i++)if(assigned_[i]&&copy_[i]!==base_[i]){const path=basePath.concat([i]);patches.push({op:REPLACE,path,value:clonePatchValueIfNeeded(copy_[i])}),inversePatches.push({op:REPLACE,path,value:clonePatchValueIfNeeded(base_[i])})}for(let i=base_.length;i<copy_.length;i++){const path=basePath.concat([i]);patches.push({op:ADD,path,value:clonePatchValueIfNeeded(copy_[i])})}for(let i=copy_.length-1;base_.length<=i;--i){const path=basePath.concat([i]);inversePatches.push({op:REMOVE,path})}}(state,basePath,patches,inversePatches);case 3:return function generateSetPatches(state,basePath,patches,inversePatches){let{base_,copy_}=state,i=0;base_.forEach((value=>{if(!copy_.has(value)){const path=basePath.concat([i]);patches.push({op:REMOVE,path,value}),inversePatches.unshift({op:ADD,path,value})}i++})),i=0,copy_.forEach((value=>{if(!base_.has(value)){const path=basePath.concat([i]);patches.push({op:ADD,path,value}),inversePatches.unshift({op:REMOVE,path,value})}i++}))}(state,basePath,patches,inversePatches)}},generateReplacementPatches_:function generateReplacementPatches_(baseValue,replacement,patches,inversePatches){patches.push({op:REPLACE,path:[],value:replacement===NOTHING?void 0:replacement}),inversePatches.push({op:REPLACE,path:[],value:baseValue})}})}var immer=new class{constructor(config){this.autoFreeze_=!0,this.useStrictShallowCopy_=!1,this.produce=(base,recipe,patchListener)=>{if("function"==typeof base&&"function"!=typeof recipe){const defaultBase=recipe;recipe=base;const self=this;return function curriedProduce(base2=defaultBase,...args){return self.produce(base2,(draft=>recipe.call(this,draft,...args)))}}let result;if("function"!=typeof recipe&&die(6),void 0!==patchListener&&"function"!=typeof patchListener&&die(7),isDraftable(base)){const scope=enterScope(this),proxy=createProxy(base,void 0);let hasError=!0;try{result=recipe(proxy),hasError=!1}finally{hasError?revokeScope(scope):leaveScope(scope)}return usePatchesInScope(scope,patchListener),processResult(result,scope)}if(!base||"object"!=typeof base){if(result=recipe(base),void 0===result&&(result=base),result===NOTHING&&(result=void 0),this.autoFreeze_&&freeze(result,!0),patchListener){const p=[],ip=[];getPlugin("Patches").generateReplacementPatches_(base,result,p,ip),patchListener(p,ip)}return result}die(1)},this.produceWithPatches=(base,recipe)=>{if("function"==typeof base)return(state,...args)=>this.produceWithPatches(state,(draft=>base(draft,...args)));let patches,inversePatches;return[this.produce(base,recipe,((p,ip)=>{patches=p,inversePatches=ip})),patches,inversePatches]},"boolean"==typeof config?.autoFreeze&&this.setAutoFreeze(config.autoFreeze),"boolean"==typeof config?.useStrictShallowCopy&&this.setUseStrictShallowCopy(config.useStrictShallowCopy)}createDraft(base){isDraftable(base)||die(8),isDraft(base)&&(base=function current(value){isDraft(value)||die(10);return currentImpl(value)}(base));const scope=enterScope(this),proxy=createProxy(base,void 0);return proxy[DRAFT_STATE].isManual_=!0,leaveScope(scope),proxy}finishDraft(draft,patchListener){const state=draft&&draft[DRAFT_STATE];state&&state.isManual_||die(9);const{scope_:scope}=state;return usePatchesInScope(scope,patchListener),processResult(void 0,scope)}setAutoFreeze(value){this.autoFreeze_=value}setUseStrictShallowCopy(value){this.useStrictShallowCopy_=value}applyPatches(base,patches){let i;for(i=patches.length-1;i>=0;i--){const patch=patches[i];if(0===patch.path.length&&"replace"===patch.op){base=patch.value;break}}i>-1&&(patches=patches.slice(i+1));const applyPatchesImpl=getPlugin("Patches").applyPatches_;return isDraft(base)?applyPatchesImpl(base,patches):this.produce(base,(draft=>applyPatchesImpl(draft,patches)))}},produce=immer.produce,produceWithPatches=immer.produceWithPatches.bind(immer),applyPatches=(immer.setAutoFreeze.bind(immer),immer.setUseStrictShallowCopy.bind(immer),immer.applyPatches.bind(immer));immer.createDraft.bind(immer),immer.finishDraft.bind(immer)},"./node_modules/react-redux/dist/react-redux.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{Kq:()=>Provider_default,Pj:()=>useStore,bN:()=>shallowEqual,d4:()=>useSelector,vA:()=>batch,wA:()=>useDispatch});var react__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/react/index.js"),use_sync_external_store_with_selector_js__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/use-sync-external-store/with-selector.js");function defaultNoopBatch(callback){callback()}var nullListeners={notify(){},get:()=>[]};function createSubscription(store,parentSub){let unsubscribe,listeners=nullListeners,subscriptionsAmount=0,selfSubscribed=!1;function handleChangeWrapper(){subscription.onStateChange&&subscription.onStateChange()}function trySubscribe(){subscriptionsAmount++,unsubscribe||(unsubscribe=parentSub?parentSub.addNestedSub(handleChangeWrapper):store.subscribe(handleChangeWrapper),listeners=function createListenerCollection(){let first=null,last=null;return{clear(){first=null,last=null},notify(){defaultNoopBatch((()=>{let listener=first;for(;listener;)listener.callback(),listener=listener.next}))},get(){const listeners=[];let listener=first;for(;listener;)listeners.push(listener),listener=listener.next;return listeners},subscribe(callback){let isSubscribed=!0;const listener=last={callback,next:null,prev:last};return listener.prev?listener.prev.next=listener:first=listener,function unsubscribe(){isSubscribed&&null!==first&&(isSubscribed=!1,listener.next?listener.next.prev=listener.prev:last=listener.prev,listener.prev?listener.prev.next=listener.next:first=listener.next)}}}}())}function tryUnsubscribe(){subscriptionsAmount--,unsubscribe&&0===subscriptionsAmount&&(unsubscribe(),unsubscribe=void 0,listeners.clear(),listeners=nullListeners)}const subscription={addNestedSub:function addNestedSub(listener){trySubscribe();const cleanupListener=listeners.subscribe(listener);let removed=!1;return()=>{removed||(removed=!0,cleanupListener(),tryUnsubscribe())}},notifyNestedSubs:function notifyNestedSubs(){listeners.notify()},handleChangeWrapper,isSubscribed:function isSubscribed(){return selfSubscribed},trySubscribe:function trySubscribeSelf(){selfSubscribed||(selfSubscribed=!0,trySubscribe())},tryUnsubscribe:function tryUnsubscribeSelf(){selfSubscribed&&(selfSubscribed=!1,tryUnsubscribe())},getListeners:()=>listeners};return subscription}var isDOM=(()=>!("undefined"==typeof window||void 0===window.document||void 0===window.document.createElement))(),isReactNative=(()=>"undefined"!=typeof navigator&&"ReactNative"===navigator.product)(),useIsomorphicLayoutEffect=(()=>isDOM||isReactNative?react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect:react__WEBPACK_IMPORTED_MODULE_0__.useEffect)();function is(x,y){return x===y?0!==x||0!==y||1/x==1/y:x!=x&&y!=y}function shallowEqual(objA,objB){if(is(objA,objB))return!0;if("object"!=typeof objA||null===objA||"object"!=typeof objB||null===objB)return!1;const keysA=Object.keys(objA),keysB=Object.keys(objB);if(keysA.length!==keysB.length)return!1;for(let i=0;i<keysA.length;i++)if(!Object.prototype.hasOwnProperty.call(objB,keysA[i])||!is(objA[keysA[i]],objB[keysA[i]]))return!1;return!0}Object.defineProperty,Object.getOwnPropertyNames,Object.getOwnPropertySymbols,Object.getOwnPropertyDescriptor,Object.getPrototypeOf,Object.prototype;var ContextKey=Symbol.for("react-redux-context"),gT="undefined"!=typeof globalThis?globalThis:{};function getContext(){if(!react__WEBPACK_IMPORTED_MODULE_0__.createContext)return{};const contextMap=gT[ContextKey]??=new Map;let realContext=contextMap.get(react__WEBPACK_IMPORTED_MODULE_0__.createContext);return realContext||(realContext=react__WEBPACK_IMPORTED_MODULE_0__.createContext(null),contextMap.set(react__WEBPACK_IMPORTED_MODULE_0__.createContext,realContext)),realContext}var ReactReduxContext=getContext();var Provider_default=function Provider(providerProps){const{children,context,serverState,store}=providerProps,contextValue=react__WEBPACK_IMPORTED_MODULE_0__.useMemo((()=>{const subscription=createSubscription(store);return{store,subscription,getServerState:serverState?()=>serverState:void 0}}),[store,serverState]),previousState=react__WEBPACK_IMPORTED_MODULE_0__.useMemo((()=>store.getState()),[store]);useIsomorphicLayoutEffect((()=>{const{subscription}=contextValue;return subscription.onStateChange=subscription.notifyNestedSubs,subscription.trySubscribe(),previousState!==store.getState()&&subscription.notifyNestedSubs(),()=>{subscription.tryUnsubscribe(),subscription.onStateChange=void 0}}),[contextValue,previousState]);const Context=context||ReactReduxContext;return react__WEBPACK_IMPORTED_MODULE_0__.createElement(Context.Provider,{value:contextValue},children)};function createReduxContextHook(context=ReactReduxContext){return function useReduxContext2(){return react__WEBPACK_IMPORTED_MODULE_0__.useContext(context)}}var useReduxContext=createReduxContextHook();function createStoreHook(context=ReactReduxContext){const useReduxContext2=context===ReactReduxContext?useReduxContext:createReduxContextHook(context),useStore2=()=>{const{store}=useReduxContext2();return store};return Object.assign(useStore2,{withTypes:()=>useStore2}),useStore2}var useStore=createStoreHook();function createDispatchHook(context=ReactReduxContext){const useStore2=context===ReactReduxContext?useStore:createStoreHook(context),useDispatch2=()=>useStore2().dispatch;return Object.assign(useDispatch2,{withTypes:()=>useDispatch2}),useDispatch2}var useDispatch=createDispatchHook(),refEquality=(a,b)=>a===b;function createSelectorHook(context=ReactReduxContext){const useReduxContext2=context===ReactReduxContext?useReduxContext:createReduxContextHook(context),useSelector2=(selector,equalityFnOrOptions={})=>{const{equalityFn=refEquality}="function"==typeof equalityFnOrOptions?{equalityFn:equalityFnOrOptions}:equalityFnOrOptions;const reduxContext=useReduxContext2(),{store,subscription,getServerState}=reduxContext,wrappedSelector=(react__WEBPACK_IMPORTED_MODULE_0__.useRef(!0),react__WEBPACK_IMPORTED_MODULE_0__.useCallback({[selector.name]:state=>selector(state)}[selector.name],[selector])),selectedState=(0,use_sync_external_store_with_selector_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStoreWithSelector)(subscription.addNestedSub,store.getState,getServerState||store.getState,wrappedSelector,equalityFn);return react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue(selectedState),selectedState};return Object.assign(useSelector2,{withTypes:()=>useSelector2}),useSelector2}var useSelector=createSelectorHook(),batch=defaultNoopBatch},"./node_modules/redux/dist/redux.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{function formatProdErrorMessage(code){return`Minified Redux error #${code}; visit https://redux.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `}__webpack_require__.d(__webpack_exports__,{HY:()=>combineReducers,Qd:()=>isPlainObject,Tw:()=>applyMiddleware,Zz:()=>compose,ve:()=>isAction,y$:()=>createStore});var symbol_observable_default=(()=>"function"==typeof Symbol&&Symbol.observable||"@@observable")(),randomString=()=>Math.random().toString(36).substring(7).split("").join("."),actionTypes_default={INIT:`@@redux/INIT${randomString()}`,REPLACE:`@@redux/REPLACE${randomString()}`,PROBE_UNKNOWN_ACTION:()=>`@@redux/PROBE_UNKNOWN_ACTION${randomString()}`};function isPlainObject(obj){if("object"!=typeof obj||null===obj)return!1;let proto=obj;for(;null!==Object.getPrototypeOf(proto);)proto=Object.getPrototypeOf(proto);return Object.getPrototypeOf(obj)===proto||null===Object.getPrototypeOf(obj)}function createStore(reducer,preloadedState,enhancer){if("function"!=typeof reducer)throw new Error(formatProdErrorMessage(2));if("function"==typeof preloadedState&&"function"==typeof enhancer||"function"==typeof enhancer&&"function"==typeof arguments[3])throw new Error(formatProdErrorMessage(0));if("function"==typeof preloadedState&&void 0===enhancer&&(enhancer=preloadedState,preloadedState=void 0),void 0!==enhancer){if("function"!=typeof enhancer)throw new Error(formatProdErrorMessage(1));return enhancer(createStore)(reducer,preloadedState)}let currentReducer=reducer,currentState=preloadedState,currentListeners=new Map,nextListeners=currentListeners,listenerIdCounter=0,isDispatching=!1;function ensureCanMutateNextListeners(){nextListeners===currentListeners&&(nextListeners=new Map,currentListeners.forEach(((listener,key)=>{nextListeners.set(key,listener)})))}function getState(){if(isDispatching)throw new Error(formatProdErrorMessage(3));return currentState}function subscribe(listener){if("function"!=typeof listener)throw new Error(formatProdErrorMessage(4));if(isDispatching)throw new Error(formatProdErrorMessage(5));let isSubscribed=!0;ensureCanMutateNextListeners();const listenerId=listenerIdCounter++;return nextListeners.set(listenerId,listener),function unsubscribe(){if(isSubscribed){if(isDispatching)throw new Error(formatProdErrorMessage(6));isSubscribed=!1,ensureCanMutateNextListeners(),nextListeners.delete(listenerId),currentListeners=null}}}function dispatch(action){if(!isPlainObject(action))throw new Error(formatProdErrorMessage(7));if(void 0===action.type)throw new Error(formatProdErrorMessage(8));if("string"!=typeof action.type)throw new Error(formatProdErrorMessage(17));if(isDispatching)throw new Error(formatProdErrorMessage(9));try{isDispatching=!0,currentState=currentReducer(currentState,action)}finally{isDispatching=!1}return(currentListeners=nextListeners).forEach((listener=>{listener()})),action}dispatch({type:actionTypes_default.INIT});return{dispatch,subscribe,getState,replaceReducer:function replaceReducer(nextReducer){if("function"!=typeof nextReducer)throw new Error(formatProdErrorMessage(10));currentReducer=nextReducer,dispatch({type:actionTypes_default.REPLACE})},[symbol_observable_default]:function observable(){const outerSubscribe=subscribe;return{subscribe(observer){if("object"!=typeof observer||null===observer)throw new Error(formatProdErrorMessage(11));function observeState(){const observerAsObserver=observer;observerAsObserver.next&&observerAsObserver.next(getState())}observeState();return{unsubscribe:outerSubscribe(observeState)}},[symbol_observable_default](){return this}}}}}function combineReducers(reducers){const reducerKeys=Object.keys(reducers),finalReducers={};for(let i=0;i<reducerKeys.length;i++){const key=reducerKeys[i];0,"function"==typeof reducers[key]&&(finalReducers[key]=reducers[key])}const finalReducerKeys=Object.keys(finalReducers);let shapeAssertionError;try{!function assertReducerShape(reducers){Object.keys(reducers).forEach((key=>{const reducer=reducers[key];if(void 0===reducer(void 0,{type:actionTypes_default.INIT}))throw new Error(formatProdErrorMessage(12));if(void 0===reducer(void 0,{type:actionTypes_default.PROBE_UNKNOWN_ACTION()}))throw new Error(formatProdErrorMessage(13))}))}(finalReducers)}catch(e){shapeAssertionError=e}return function combination(state={},action){if(shapeAssertionError)throw shapeAssertionError;let hasChanged=!1;const nextState={};for(let i=0;i<finalReducerKeys.length;i++){const key=finalReducerKeys[i],reducer=finalReducers[key],previousStateForKey=state[key],nextStateForKey=reducer(previousStateForKey,action);if(void 0===nextStateForKey){action&&action.type;throw new Error(formatProdErrorMessage(14))}nextState[key]=nextStateForKey,hasChanged=hasChanged||nextStateForKey!==previousStateForKey}return hasChanged=hasChanged||finalReducerKeys.length!==Object.keys(state).length,hasChanged?nextState:state}}function compose(...funcs){return 0===funcs.length?arg=>arg:1===funcs.length?funcs[0]:funcs.reduce(((a,b)=>(...args)=>a(b(...args))))}function applyMiddleware(...middlewares){return createStore2=>(reducer,preloadedState)=>{const store=createStore2(reducer,preloadedState);let dispatch=()=>{throw new Error(formatProdErrorMessage(15))};const middlewareAPI={getState:store.getState,dispatch:(action,...args)=>dispatch(action,...args)},chain=middlewares.map((middleware=>middleware(middlewareAPI)));return dispatch=compose(...chain)(store.dispatch),{...store,dispatch}}}function isAction(action){return isPlainObject(action)&&"type"in action&&"string"==typeof action.type}},"./node_modules/reselect/dist/reselect.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{Mz:()=>createSelector,X4:()=>weakMapMemoize});function assertIsFunction(func,errorMessage="expected a function, instead received "+typeof func){if("function"!=typeof func)throw new TypeError(errorMessage)}var ensureIsArray=item=>Array.isArray(item)?item:[item];function getDependencies(createSelectorArgs){const dependencies=Array.isArray(createSelectorArgs[0])?createSelectorArgs[0]:createSelectorArgs;return function assertIsArrayOfFunctions(array,errorMessage="expected all items to be functions, instead received the following types: "){if(!array.every((item=>"function"==typeof item))){const itemTypes=array.map((item=>"function"==typeof item?`function ${item.name||"unnamed"}()`:typeof item)).join(", ");throw new TypeError(`${errorMessage}[${itemTypes}]`)}}(dependencies,"createSelector expects all input-selectors to be functions, but received the following types: "),dependencies}Symbol(),Object.getPrototypeOf({});var Ref="undefined"!=typeof WeakRef?WeakRef:class{constructor(value){this.value=value}deref(){return this.value}},UNTERMINATED=0,TERMINATED=1;function createCacheNode(){return{s:UNTERMINATED,v:void 0,o:null,p:null}}function weakMapMemoize(func,options={}){let fnNode=createCacheNode();const{resultEqualityCheck}=options;let lastResult,resultsCount=0;function memoized(){let cacheNode=fnNode;const{length}=arguments;for(let i=0,l=length;i<l;i++){const arg=arguments[i];if("function"==typeof arg||"object"==typeof arg&&null!==arg){let objectCache=cacheNode.o;null===objectCache&&(cacheNode.o=objectCache=new WeakMap);const objectNode=objectCache.get(arg);void 0===objectNode?(cacheNode=createCacheNode(),objectCache.set(arg,cacheNode)):cacheNode=objectNode}else{let primitiveCache=cacheNode.p;null===primitiveCache&&(cacheNode.p=primitiveCache=new Map);const primitiveNode=primitiveCache.get(arg);void 0===primitiveNode?(cacheNode=createCacheNode(),primitiveCache.set(arg,cacheNode)):cacheNode=primitiveNode}}const terminatedNode=cacheNode;let result;if(cacheNode.s===TERMINATED)result=cacheNode.v;else if(result=func.apply(null,arguments),resultsCount++,resultEqualityCheck){const lastResultValue=lastResult?.deref?.()??lastResult;null!=lastResultValue&&resultEqualityCheck(lastResultValue,result)&&(result=lastResultValue,0!==resultsCount&&resultsCount--);lastResult="object"==typeof result&&null!==result||"function"==typeof result?new Ref(result):result}return terminatedNode.s=TERMINATED,terminatedNode.v=result,result}return memoized.clearCache=()=>{fnNode=createCacheNode(),memoized.resetResultsCount()},memoized.resultsCount=()=>resultsCount,memoized.resetResultsCount=()=>{resultsCount=0},memoized}function createSelectorCreator(memoizeOrOptions,...memoizeOptionsFromArgs){const createSelectorCreatorOptions="function"==typeof memoizeOrOptions?{memoize:memoizeOrOptions,memoizeOptions:memoizeOptionsFromArgs}:memoizeOrOptions,createSelector2=(...createSelectorArgs)=>{let lastResult,recomputations=0,dependencyRecomputations=0,directlyPassedOptions={},resultFunc=createSelectorArgs.pop();"object"==typeof resultFunc&&(directlyPassedOptions=resultFunc,resultFunc=createSelectorArgs.pop()),assertIsFunction(resultFunc,`createSelector expects an output function after the inputs, but received: [${typeof resultFunc}]`);const combinedOptions={...createSelectorCreatorOptions,...directlyPassedOptions},{memoize,memoizeOptions=[],argsMemoize=weakMapMemoize,argsMemoizeOptions=[],devModeChecks={}}=combinedOptions,finalMemoizeOptions=ensureIsArray(memoizeOptions),finalArgsMemoizeOptions=ensureIsArray(argsMemoizeOptions),dependencies=getDependencies(createSelectorArgs),memoizedResultFunc=memoize((function recomputationWrapper(){return recomputations++,resultFunc.apply(null,arguments)}),...finalMemoizeOptions);const selector=argsMemoize((function dependenciesChecker(){dependencyRecomputations++;const inputSelectorResults=function collectInputSelectorResults(dependencies,inputSelectorArgs){const inputSelectorResults=[],{length}=dependencies;for(let i=0;i<length;i++)inputSelectorResults.push(dependencies[i].apply(null,inputSelectorArgs));return inputSelectorResults}(dependencies,arguments);return lastResult=memoizedResultFunc.apply(null,inputSelectorResults),lastResult}),...finalArgsMemoizeOptions);return Object.assign(selector,{resultFunc,memoizedResultFunc,dependencies,dependencyRecomputations:()=>dependencyRecomputations,resetDependencyRecomputations:()=>{dependencyRecomputations=0},lastResult:()=>lastResult,recomputations:()=>recomputations,resetRecomputations:()=>{recomputations=0},memoize,argsMemoize})};return Object.assign(createSelector2,{withTypes:()=>createSelector2}),createSelector2}var createSelector=createSelectorCreator(weakMapMemoize),createStructuredSelector=Object.assign(((inputSelectorsObject,selectorCreator=createSelector)=>{!function assertIsObject(object,errorMessage="expected an object, instead received "+typeof object){if("object"!=typeof object)throw new TypeError(errorMessage)}(inputSelectorsObject,"createStructuredSelector expects first argument to be an object where each property is a selector, instead received a "+typeof inputSelectorsObject);const inputSelectorKeys=Object.keys(inputSelectorsObject);return selectorCreator(inputSelectorKeys.map((key=>inputSelectorsObject[key])),((...inputSelectorResults)=>inputSelectorResults.reduce(((composition,value,index)=>(composition[inputSelectorKeys[index]]=value,composition)),{})))}),{withTypes:()=>createStructuredSelector})},"./node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.production.js":(__unused_webpack_module,exports,__webpack_require__)=>{var React=__webpack_require__("./node_modules/react/index.js");var objectIs="function"==typeof Object.is?Object.is:function is(x,y){return x===y&&(0!==x||1/x==1/y)||x!=x&&y!=y},useSyncExternalStore=React.useSyncExternalStore,useRef=React.useRef,useEffect=React.useEffect,useMemo=React.useMemo,useDebugValue=React.useDebugValue;exports.useSyncExternalStoreWithSelector=function(subscribe,getSnapshot,getServerSnapshot,selector,isEqual){var instRef=useRef(null);if(null===instRef.current){var inst={hasValue:!1,value:null};instRef.current=inst}else inst=instRef.current;instRef=useMemo((function(){function memoizedSelector(nextSnapshot){if(!hasMemo){if(hasMemo=!0,memoizedSnapshot=nextSnapshot,nextSnapshot=selector(nextSnapshot),void 0!==isEqual&&inst.hasValue){var currentSelection=inst.value;if(isEqual(currentSelection,nextSnapshot))return memoizedSelection=currentSelection}return memoizedSelection=nextSnapshot}if(currentSelection=memoizedSelection,objectIs(memoizedSnapshot,nextSnapshot))return currentSelection;var nextSelection=selector(nextSnapshot);return void 0!==isEqual&&isEqual(currentSelection,nextSelection)?(memoizedSnapshot=nextSnapshot,currentSelection):(memoizedSnapshot=nextSnapshot,memoizedSelection=nextSelection)}var memoizedSnapshot,memoizedSelection,hasMemo=!1,maybeGetServerSnapshot=void 0===getServerSnapshot?null:getServerSnapshot;return[function(){return memoizedSelector(getSnapshot())},null===maybeGetServerSnapshot?void 0:function(){return memoizedSelector(maybeGetServerSnapshot())}]}),[getSnapshot,getServerSnapshot,selector,isEqual]);var value=useSyncExternalStore(subscribe,instRef[0],instRef[1]);return useEffect((function(){inst.hasValue=!0,inst.value=value}),[value]),useDebugValue(value),value}},"./node_modules/use-sync-external-store/with-selector.js":(module,__unused_webpack_exports,__webpack_require__)=>{module.exports=__webpack_require__("./node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.production.js")}}]);